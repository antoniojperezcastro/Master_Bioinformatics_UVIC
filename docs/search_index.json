[
["index.html", "Master in Bioinformatics and Omic Data Analysis 1 Introduction", " Master in Bioinformatics and Omic Data Analysis Juan R González 2021-01-21 1 Introduction This bookdown is the supplementary material for different courses on Bioinformatics and Omics data analysis given at Master in Boinformatics of Barcelona Autonomous University and Master in Omic Data Analysis of Vic University The contents include: Chapter I: Bioconductor Section 1: Overview Section 2: Infrastructures Section 3: Annotation Chapter II: Genomic data analysis Section 1: Descriptive analysis Section 2: Single association analysis Section 4: Gene-interaction analysis Section 4: Haplotype analysis Chapter III: Genome-wide association analyses (GWAS) Section 1: Quality control of SNPs Section 2: Quality control of individuals Section 3: Population stratification Section 4: Association analyses Final Chapter: Exercises This material is licensed under Creative Commons Attribution 4.0 International License. "],
["bioconductor.html", "2 Bioconductor 2.1 Bioconductor’s overview 2.2 Bioconductor infrastructures 2.3 Annotation 2.4 annotate package 2.5 BioMart 2.6 Annotate SNPs", " 2 Bioconductor This chapter offers a summary of the main data structures that are implemented in Bioconductor for dealing with genomic, transcriptomic and epigenomic data data. Omic data is typically composed of three datasets: one containing the actual high-dimensional data of omic variables per individuals, annotation data that specifies the characteristics of the variables and phenotypic information that encodes the subject’s traits of interest, covariates and sampling characteristics. For instance, transcriptomic data is stored in a ExpressionSet object, which is a data structure that contains the transcription values of individuals at each transcription probe, the genomic information for the transcription probes and the phenotypes of the individuals. Specific data is accessed, processed and analyzed with specific functions from diverse packages, conceived as methods acting on the ExpressionSet object. The aim of this chapter is then to introduce the specific omic objects available in Bioconductor. In the following chapters, we will introduce the packages that have been implemented to process and analyze these objects. We finish the chapter by illustrating how to perform genomic annotation which is crucial for interpreting results. Some of the data we are working with are available at our repository called brgedata. Therefore, I would recommend to install it just executing: BiocManager::install(&quot;isglobal-brge/brgedata&quot;) 2.1 Bioconductor’s overview Bioconductor: Analysis and comprehension of high-throughput genomic data Statistical analysis: large data, technological artifacts, designed experiments; rigorous Comprehension: biological context, visualization, reproducibility High-throughput Sequencing: RNASeq, ChIPSeq, variants, copy number, … Microarrays: expression, SNP, … Flow cytometry, proteomics, images, … Packages, vignettes, work flows 1974 software packages (Nov’20); also… ‘Annotation’ packages – static data bases of identifier maps, gene models, pathways, etc; e.g., [TxDb.Hsapiens.UCSC.hg19.knownGene][] ’Experiment packages – data sets used to illustrate software functionality, e.g., [airway][] Discover and navigate via [biocViews][] Package ‘landing page’ Title, author / maintainer, short description, citation, installation instructions, …, download statistics All user-visible functions have help pages, most with runnable examples ‘Vignettes’ an important feature in Bioconductor – narrative documents illustrating how to use the package, with integrated code ‘Release’ (every six months) and ‘devel’ branches Support site; videos; recent courses. Common Workflows Package installation and use A package needs to be installed once, using the instructions on the package landing page (e.g., [DESeq2][]). source(&quot;https://bioconductor.org/biocLite.R&quot;) biocLite(c(&quot;DESeq2&quot;, &quot;org.Hs.eg.db&quot;)) NEW functions have been created require(BiocManager) install(&quot;DESeq2&quot;) # or BiocManager::install(&quot;DESeq2&quot;) older versions can be installed by ```r BiocManager::install(&quot;DESeq2&quot;, version = &quot;3.8&quot;) ``` biocLite() and install() install Bioconductor and [CRAN][] Github packages can be install by devtools::install_github(&quot;isglobal-brge/SNPassoc&quot;) Once installed, the package can be loaded into an R session library(GenomicRanges) and the help system queried interactively, as outlined above: help(package=&quot;GenomicRanges&quot;) vignette(package=&quot;GenomicRanges&quot;) vignette(package=&quot;GenomicRanges&quot;, &quot;GenomicRangesHOWTOs&quot;) ?GRanges 2.2 Bioconductor infrastructures 2.2.1 snpMatrix SNP array data can be stored in different formats. PLINK binary format is a common and efficient system to store and analyze genotype data. It was developed to analyze data with PLINK software (Purcell et al. 2007) but its efficiency in storing data in binary files has made it one of the standard formats for other software packages, including some in Bioconductor. PLINK stores SNP genomic data, annotation and phenotype information in three different files with extensions .bed, .bim and .fam: binary BED file: Contains the genomic SNP data, whose values are encoded in two bits (Homozygous normal 00, Heterozygous 10, Homozygous variant 11, missing 01). text BIM file: Contains SNPs annotations. Each row is a SNP and contains six columns: chromosome, SNP name, position in morgans, base-pair coordinates, allele 1 (reference nucleotide), allele 2 (alternative nucleotide). text FAM file: Contains the subject’s information. Each row is an individual and contains six variables: the Family identifier (ID), Individual ID, Paternal ID, Maternal ID, Sex (1=male; 2=female; other=unknown), phenotypes. Covariates can be added in additional columns. PLINK data can be loaded into R with the read.plink() function from snpStats Bioconductor’s package. The function requires the full path for the BED, BIM and FAM files, or only their name when the working directory of R contains the PLINK files. library(snpStats) ob.plink &lt;- read.plink(bed = &quot;obesity.bed&quot;, bim = &quot;obesity.bim&quot;, fam = &quot;obesity.fam&quot;) In case of having the three files with the same name (i.e. obesity.fam, obesity.bim and obesity.bed) the following simplification may be convenient: snps &lt;- read.plink(&quot;obesity&quot;) Let us assume we have our PLINK data in folder called “data” at our working directory. Therefore, they can also be loaded by library(snpStats) path &lt;- &quot;data&quot; snps &lt;- read.plink(file.path(path, &quot;obesity&quot;)) names(snps) [1] &quot;genotypes&quot; &quot;fam&quot; &quot;map&quot; The read.plink() function returns a list with the three fields genotypes, fam and map that correspond to the three uploaded files. The genotypes field contains the genotype data stored in a snpMatrix object (individuals in rows and SNPs in columns). geno &lt;- snps$genotypes geno A SnpMatrix with 2312 rows and 100000 columns Row names: 100 ... 998 Col names: MitoC3993T ... rs28600179 Genotypes are encoded as raw variables for storage efficiency. While individual values can be extracted with array syntax, manipulation of data is usually performed by methods that act on the complete object. The fam field contains the individual’s information in a data.frame object: individuals &lt;- snps$fam head(individuals) pedigree member father mother sex affected 100 FAM_OB 100 NA NA 1 1 1001 FAM_OB 1001 NA NA 1 1 1004 FAM_OB 1004 NA NA 2 2 1005 FAM_OB 1005 NA NA 1 2 1006 FAM_OB 1006 NA NA 2 1 1008 FAM_OB 1008 NA NA 1 1 The map field contains the SNPs annotation in a data.frame: annotation &lt;- snps$map head(annotation) chromosome snp.name cM position allele.1 allele.2 MitoC3993T NA MitoC3993T NA 3993 T C MitoG4821A NA MitoG4821A NA 4821 A G MitoG6027A NA MitoG6027A NA 6027 A G MitoT6153C NA MitoT6153C NA 6153 C T MitoC7275T NA MitoC7275T NA 7275 T C MitoT9699C NA MitoT9699C NA 9699 C T Subsetting SNP data requires at least two different operations. For instance, if we are interested in extracting the SNPs of chromosome 1, we need to select those variants in annotation that are located in chromosome 1 and then subset the snpMatrix object as a typical matrix. annotationChr1 &lt;- annotation[annotation$chromosome == &quot;1&quot; &amp; !is.na(annotation$chromosome), ] genoChr1 &lt;- geno[, rownames(annotationChr1)] genoChr1 A SnpMatrix with 2312 rows and 7721 columns Row names: 100 ... 998 Col names: rs12354060 ... rs7527472 Subsetting samples follow a similar pattern. Suppose we want to select the genotypes of the control individuals. Case-control status is often encoded in the FAM file and therefore uploaded in the fam field. In our example, controls are coded with 1 and cases with 2 in the variable “affected” of individuals. Therefore, the genotypes of the control samples are extracted by individualsCtrl &lt;- individuals[individuals$affected == 1, ] genoCtrl &lt;- geno[rownames(individualsCtrl), ] genoCtrl A SnpMatrix with 1587 rows and 100000 columns Row names: 100 ... 998 Col names: MitoC3993T ... rs28600179 2.2.2 ExpressionSet ExpressionSetwas one of the first implementations of Bioconductor to manage omic experiments. This figure illustrates how it is implemented Figure 2.1: ExpressionSet scheme. Although its use is discouraged in Bioconductor’s guidelines for the development of current and future packages, most publicly available data is available in this structure while future packages are still required to be able to upload and operate with it. The GEO repository contains thousands of transcriptomic experiments that are available in ExpressionSet format. Data available in GEO repository can be donwloaded into R as an ExpressionSet using GEOquery package. Let us donwload the experiment with accession number GSE63061 from the GEO website library(GEOquery) gsm.expr &lt;- getGEO(&quot;GSE63061&quot;, destdir = &quot;.&quot;)[[1]] gsm.expr ExpressionSet (storageMode: lockedEnvironment) assayData: 32049 features, 388 samples element names: exprs protocolData: none phenoData sampleNames: GSM1539409 GSM1539410 ... GSM1539796 (388 total) varLabels: title geo_accession ... tissue:ch1 (40 total) varMetadata: labelDescription featureData featureNames: ILMN_1343291 ILMN_1343295 ... ILMN_3311190 (32049 total) fvarLabels: ID Species ... GB_ACC (30 total) fvarMetadata: Column Description labelDescription experimentData: use &#39;experimentData(object)&#39; pubMedIds: 26343147 Annotation: GPL10558 gsm.expr is an object of class ExpressionSet that has three main slots. Transcriptomic data is stored in the assayData slot, phenotypes are in phenoData and probe annotation in featuredData. There are three other slots protocolData, experimentData and annotation that specify equipment-generated information about protocols, resulting publications and the platform on which the samples were assayed. Methods are implemented to extract the data from each slot of the object. For instance exprs extracts the transcriptomic data in a matrix where subjects are columns and probes are rows expr &lt;- exprs(gsm.expr) dim(expr) [1] 32049 388 expr[1:5,1:5] GSM1539409 GSM1539410 GSM1539411 GSM1539412 GSM1539413 ILMN_1343291 12.552807 12.711459 13.088393 12.643831 13.098389 ILMN_1343295 10.101556 9.776015 9.594397 10.126782 10.223301 ILMN_1651209 6.084671 6.255012 6.160485 6.109219 6.069960 ILMN_1651210 6.068805 6.016468 6.024322 6.016118 6.056163 ILMN_1651221 6.121060 6.173167 6.039552 6.111306 6.089542 phenoData() retrieves the subjects’ phenotypes in an AnnotatedDataFrame object which is converted to a data.frame by the function pData() #get phenotype data pheno &lt;- phenoData(gsm.expr) pheno An object of class &#39;AnnotatedDataFrame&#39; sampleNames: GSM1539409 GSM1539410 ... GSM1539796 (388 total) varLabels: title geo_accession ... tissue:ch1 (40 total) varMetadata: labelDescription phenoDataFrame &lt;- pData(gsm.expr) phenoDataFrame[1:5,1:4] title geo_accession status GSM1539409 7196843065_F GSM1539409 Public on Aug 05 2015 GSM1539410 7196843076_G GSM1539410 Public on Aug 05 2015 GSM1539411 7196843068_B GSM1539411 Public on Aug 05 2015 GSM1539412 7196843063_B GSM1539412 Public on Aug 05 2015 GSM1539413 7196843065_L GSM1539413 Public on Aug 05 2015 submission_date GSM1539409 Nov 06 2014 GSM1539410 Nov 06 2014 GSM1539411 Nov 06 2014 GSM1539412 Nov 06 2014 GSM1539413 Nov 06 2014 #Alzheimer&#39;s case control variable summary(phenoDataFrame$characteristics_ch1) Length Class Mode 388 character character Finally the fData() function gets the probes’ annotationin a data.frame probes &lt;- fData(gsm.expr) probes[1:5, 1:5] ID Species Source Search_Key Transcript ILMN_1343291 ILMN_1343291 Homo sapiens RefSeq NM_001402.4 ILMN_5311 ILMN_1343295 ILMN_1343295 Homo sapiens RefSeq ILMN_27206 ILMN_1651209 ILMN_1651209 Homo sapiens RefSeq NM_182838.1 ILMN_8692 ILMN_1651210 ILMN_1651210 Homo sapiens RefSeq XM_941691.1 ILMN_138115 ILMN_1651221 ILMN_1651221 Homo sapiens RefSeq XM_926225.1 ILMN_33528 2.2.3 SummarizedExperiment The SummarizedExperiment class is a comprehensive data structure that can be used to store expression and methylation data from microarrays or read counts from RNA-seq experiments, among others. A SummarizedExperiment object contains slots for one or more datasets, feature annotation (e.g. genes, transcripts, SNPs, CpGs), individual phenotypes and experimental details, such as laboratory and experimental protocols. In a SummarizedExperiment, the rows of omic data are features and columns are subjects. SummarizedExperiment Information is coordinated across the object’s slots. For instance, subsetting samples in the assay matrix automatically subsets them in the phenotype metadata. A SummarizedExperimentobject is easily manipulated and constitutes the input and output of many of Bioconductor’s methods. Data is retrieved from a SummarizedExperiment by using specific methods or accessors. We illustrate the functions with brge_methy which includes real methylation data and is available from the Bioconductor’s brgedata package. The data is made available by loading of the package library(brgedata) brge_methy class: GenomicRatioSet dim: 392277 20 metadata(0): assays(1): Beta rownames(392277): cg13869341 cg24669183 ... cg26251715 cg25640065 rowData names(14): Forward_Sequence SourceSeq ... Regulatory_Feature_Group DHS colnames(20): x0017 x0043 ... x0077 x0079 colData names(9): age sex ... Mono Neu Annotation array: IlluminaHumanMethylation450k annotation: ilmn12.hg19 Preprocessing Method: NA minfi version: NA Manifest version: NA extends(&quot;GenomicRatioSet&quot;) [1] &quot;GenomicRatioSet&quot; &quot;RangedSummarizedExperiment&quot; [3] &quot;SummarizedExperiment&quot; &quot;Vector&quot; [5] &quot;Annotated&quot; &quot;vector_OR_Vector&quot; The function extends() shows that the data has been encoded in an object of GenomicRatioSet class, which is an extension of the more primitive classes RangedSummarizedExperiment and SummarizedExperiment. brge_methy illustrates a typical object within Bioconductor’s framework, as it is a structure that inherits different types of classes in an established hierarchy. For each class, there are specific methods which are properly inherited across classes. For instance, in our example, SummarizedExperiment is brge_methy’s most primitive omic class and, therefore, all the methods of SummarizedExperiment apply to it. In particular, the methylation data that is stored in the object can be extracted with the function assay() betas &lt;- assay(brge_methy) betas[1:5, 1:4] x0017 x0043 x0036 x0041 cg13869341 0.90331003 0.90082827 0.8543610 0.84231205 cg24669183 0.86349463 0.84009629 0.8741255 0.85122181 cg15560884 0.65986032 0.69634338 0.6931083 0.69752294 cg01014490 0.01448404 0.01509478 0.0163614 0.01322362 cg17505339 0.92176287 0.92060149 0.9101060 0.93249167 The assay slot of a SummarizedExperiment object can contain any type of data (i.e. numeric, character, factor…), structure or large on-disk representations, such as a HDF5Array. Feature annotation data is accessed with the function rowData(): rowData(brge_methy)[,2:5] DataFrame with 392277 rows and 4 columns SourceSeq &lt;character&gt; cg13869341 CCGGTGGCTGGCCACTCTGCTAGAGTCCATCCGCCAAGCTGGGGGCATCG cg24669183 TCACCGCCTTGACAGCTTTGCAGAGTGCTGCTCAGGTATTCTGCAAGACG cg15560884 CGCGTAAACAAGGGAAGCTGAGTAATTGTATGTTCAAATACTTGCAAAAC cg01014490 TCAGAACTCGCGGTGGGGGCTGCTGGTTCTTCCAGGAGCGCGCATGAGCG cg17505339 AAACAAACAAAGATATCAAGCCACAGATTCAAAGTGCTATAAACTCCACG ... ... cg04964672 CGGCGGCTTTCCACGCTGCGGCTTGGAGTGGTCCTTGTTTAGATTCCTTT cg01086462 CGCAGGTATGGTGTACATTAAGCAGGCAGGGTCAATCAGGGATGGTCTAT cg02233183 CAAAATGAATGAAATTTACAAACCCAGCAGCCAATAGATCTCCAGAGTCG cg26251715 CGCTGGTTGTCCAGGCTGGAATGCAATGGTGCAATGTCCGCTCACTCCAA cg25640065 CGGGGCAGGGGTCCGTAACTGCAGCCCTCCATGCCTGAGCCCCCCACCCC Random_Loci Methyl27_Loci genes &lt;character&gt; &lt;character&gt; &lt;character&gt; cg13869341 WASH5P cg24669183 cg15560884 cg01014490 cg17505339 ... ... ... ... cg04964672 cg01086462 cg02233183 NLGN4Y;NLGN4Y cg26251715 TTTY14 cg25640065 which returns a data.frame object. In our example, it contains the sequences and the genes associated with the CpG probes, among other information. 2.2.4 Genomic Ranges (GRanges) The Bioconductor’s package GenomicRanges aims to represent and manipulate the genomic annotation of molecular omic data under a reference genome. It contains functions to select specific regions and perform operations with them (Lawrence et al. 2013). Objects of GRanges class are important to annotate and manipulate genomic, transcriptomic and methylomic data. In particular, they are used in conjunction with SummarizedExperiment, within the RangedSummarizedExperiment class that is explained in the following section. Annotation data refers to the characteristics of the variables in the high-dimensional data set. In particular for omic data relative to DNA structure and function, each variable may be given a location in a reference genome. While not two genomes are identical, the construction of a reference genome allows the mapping of specific characteristics of individual genomes to a common ground where they can be compared. The reference genome defines a coordinate system: “chromosome id” and “position along the chromosome”. For instance, a position such as chr10:4567-5671 would represent the 4567th to the 5671st base pair on the reference’s chromosome 10. The main functionalities implemented GenomicRanges are methods on GRanges objects. Objects are created by the function GRanges, minimum requirements are the genomic positions given by the chromosome seqnames and base pair coordinates ranges. Other metadata (e.g. variables) can be added to provide further information about each segment. We illustrate GenomicRanges creating 8 segments on either chr1 or chr2, each with defined start and end points. We add strand information, passed through the argument strand, to indicate the direction of each sequence. We also add a hypothetical variable disease that indicates whether asthma or obesity have been associated with each interval library(GenomicRanges) gr &lt;- GRanges(seqnames=c(rep(&quot;chr1&quot;, 4), rep(&quot;chr2&quot;, 4)), ranges = IRanges(start = c(1000, 1800, 5300, 7900, 1300, 2100, 3400, 6700), end =c(2200, 3900, 5400, 8100, 2600, 3300, 4460, 6850)), strand = rep(c(&quot;+&quot;, &quot;-&quot;), 4), disease = c(rep(&quot;Asthma&quot;,4), rep(&quot;Obesity&quot;,4))) gr GRanges object with 8 ranges and 1 metadata column: seqnames ranges strand | disease &lt;Rle&gt; &lt;IRanges&gt; &lt;Rle&gt; | &lt;character&gt; [1] chr1 1000-2200 + | Asthma [2] chr1 1800-3900 - | Asthma [3] chr1 5300-5400 + | Asthma [4] chr1 7900-8100 - | Asthma [5] chr2 1300-2600 + | Obesity [6] chr2 2100-3300 - | Obesity [7] chr2 3400-4460 + | Obesity [8] chr2 6700-6850 - | Obesity ------- seqinfo: 2 sequences from an unspecified genome; no seqlengths gr is our constructed object of class GRanges. The object responds to the usual array and subset extraction given by squared parentheses gr[1] GRanges object with 1 range and 1 metadata column: seqnames ranges strand | disease &lt;Rle&gt; &lt;IRanges&gt; &lt;Rle&gt; | &lt;character&gt; [1] chr1 1000-2200 + | Asthma ------- seqinfo: 2 sequences from an unspecified genome; no seqlengths However, there are also specific functions to access and modify information. For instance, seqnames() extract the chromosomes defined in our examples, whose first element can be redefined accordingly: seqnames(gr) factor-Rle of length 8 with 2 runs Lengths: 4 4 Values : chr1 chr2 Levels(2): chr1 chr2 seqnames(gr)[1] &lt;- &quot;chr2&quot; gr GRanges object with 8 ranges and 1 metadata column: seqnames ranges strand | disease &lt;Rle&gt; &lt;IRanges&gt; &lt;Rle&gt; | &lt;character&gt; [1] chr2 1000-2200 + | Asthma [2] chr1 1800-3900 - | Asthma [3] chr1 5300-5400 + | Asthma [4] chr1 7900-8100 - | Asthma [5] chr2 1300-2600 + | Obesity [6] chr2 2100-3300 - | Obesity [7] chr2 3400-4460 + | Obesity [8] chr2 6700-6850 - | Obesity ------- seqinfo: 2 sequences from an unspecified genome; no seqlengths This is important to annotation using different system. NCBI encodes chromosomes as 1, 2, 3, …; while UCSC uses chr1, chr2, … The chromosome style can be changed using seqlevelsStyle(gr) &lt;- &quot;NCBI&quot; gr GRanges object with 8 ranges and 1 metadata column: seqnames ranges strand | disease &lt;Rle&gt; &lt;IRanges&gt; &lt;Rle&gt; | &lt;character&gt; [1] 2 1000-2200 + | Asthma [2] 1 1800-3900 - | Asthma [3] 1 5300-5400 + | Asthma [4] 1 7900-8100 - | Asthma [5] 2 1300-2600 + | Obesity [6] 2 2100-3300 - | Obesity [7] 2 3400-4460 + | Obesity [8] 2 6700-6850 - | Obesity ------- seqinfo: 2 sequences from an unspecified genome; no seqlengths Let’s us write back the UCSC style seqlevelsStyle(gr) &lt;- &quot;UCSC&quot; gr GRanges object with 8 ranges and 1 metadata column: seqnames ranges strand | disease &lt;Rle&gt; &lt;IRanges&gt; &lt;Rle&gt; | &lt;character&gt; [1] chr2 1000-2200 + | Asthma [2] chr1 1800-3900 - | Asthma [3] chr1 5300-5400 + | Asthma [4] chr1 7900-8100 - | Asthma [5] chr2 1300-2600 + | Obesity [6] chr2 2100-3300 - | Obesity [7] chr2 3400-4460 + | Obesity [8] chr2 6700-6850 - | Obesity ------- seqinfo: 2 sequences from an unspecified genome; no seqlengths Additional information can be added to the current object as a new field of a list gr$gene_id &lt;- paste0(&quot;Gene&quot;, 1:8) gr GRanges object with 8 ranges and 2 metadata columns: seqnames ranges strand | disease gene_id &lt;Rle&gt; &lt;IRanges&gt; &lt;Rle&gt; | &lt;character&gt; &lt;character&gt; [1] chr2 1000-2200 + | Asthma Gene1 [2] chr1 1800-3900 - | Asthma Gene2 [3] chr1 5300-5400 + | Asthma Gene3 [4] chr1 7900-8100 - | Asthma Gene4 [5] chr2 1300-2600 + | Obesity Gene5 [6] chr2 2100-3300 - | Obesity Gene6 [7] chr2 3400-4460 + | Obesity Gene7 [8] chr2 6700-6850 - | Obesity Gene8 ------- seqinfo: 2 sequences from an unspecified genome; no seqlengths GenomicRanges provides different methods to perform arithmetic with the ranges, see ?GRanges for a full list. For instance, with shift() an interval is moved a given base-pair distance and with flank() the interval is stretched #shift: move all intervals 10 base pair towards the end shift(gr, 10) GRanges object with 8 ranges and 2 metadata columns: seqnames ranges strand | disease gene_id &lt;Rle&gt; &lt;IRanges&gt; &lt;Rle&gt; | &lt;character&gt; &lt;character&gt; [1] chr2 1010-2210 + | Asthma Gene1 [2] chr1 1810-3910 - | Asthma Gene2 [3] chr1 5310-5410 + | Asthma Gene3 [4] chr1 7910-8110 - | Asthma Gene4 [5] chr2 1310-2610 + | Obesity Gene5 [6] chr2 2110-3310 - | Obesity Gene6 [7] chr2 3410-4470 + | Obesity Gene7 [8] chr2 6710-6860 - | Obesity Gene8 ------- seqinfo: 2 sequences from an unspecified genome; no seqlengths #shift: move each intervals individually shift(gr, seq(10,100, length=8)) GRanges object with 8 ranges and 2 metadata columns: seqnames ranges strand | disease gene_id &lt;Rle&gt; &lt;IRanges&gt; &lt;Rle&gt; | &lt;character&gt; &lt;character&gt; [1] chr2 1010-2210 + | Asthma Gene1 [2] chr1 1822-3922 - | Asthma Gene2 [3] chr1 5335-5435 + | Asthma Gene3 [4] chr1 7948-8148 - | Asthma Gene4 [5] chr2 1361-2661 + | Obesity Gene5 [6] chr2 2174-3374 - | Obesity Gene6 [7] chr2 3487-4547 + | Obesity Gene7 [8] chr2 6800-6950 - | Obesity Gene8 ------- seqinfo: 2 sequences from an unspecified genome; no seqlengths #flank: recover regions next to the input set. # For a 50 base stretch upstream (negative value for # downstream) flank(gr, 50) GRanges object with 8 ranges and 2 metadata columns: seqnames ranges strand | disease gene_id &lt;Rle&gt; &lt;IRanges&gt; &lt;Rle&gt; | &lt;character&gt; &lt;character&gt; [1] chr2 950-999 + | Asthma Gene1 [2] chr1 3901-3950 - | Asthma Gene2 [3] chr1 5250-5299 + | Asthma Gene3 [4] chr1 8101-8150 - | Asthma Gene4 [5] chr2 1250-1299 + | Obesity Gene5 [6] chr2 3301-3350 - | Obesity Gene6 [7] chr2 3350-3399 + | Obesity Gene7 [8] chr2 6851-6900 - | Obesity Gene8 ------- seqinfo: 2 sequences from an unspecified genome; no seqlengths GenomicRanges also includes methods for aggregating and summarizing GRangesobjects. The functions reduce(), disjoint() and coverage() are most useful. disjoin(), for instance, reduces the intervals into the smallest set of unique, non-overlapping pieces that make up the original object. It is strand-specific by default, but this can be avoided with ignore.strand=TRUE. disjoin(gr, ignore.strand=TRUE) GRanges object with 10 ranges and 0 metadata columns: seqnames ranges strand &lt;Rle&gt; &lt;IRanges&gt; &lt;Rle&gt; [1] chr1 1800-3900 * [2] chr1 5300-5400 * [3] chr1 7900-8100 * [4] chr2 1000-1299 * [5] chr2 1300-2099 * [6] chr2 2100-2200 * [7] chr2 2201-2600 * [8] chr2 2601-3300 * [9] chr2 3400-4460 * [10] chr2 6700-6850 * ------- seqinfo: 2 sequences from an unspecified genome; no seqlengths reduce() creates the smallest range set of unique, non-overlapping intervals. Strand information is also taken into account by default and can also be turned off reduce(gr, ignore.strand=TRUE) GRanges object with 6 ranges and 0 metadata columns: seqnames ranges strand &lt;Rle&gt; &lt;IRanges&gt; &lt;Rle&gt; [1] chr1 1800-3900 * [2] chr1 5300-5400 * [3] chr1 7900-8100 * [4] chr2 1000-3300 * [5] chr2 3400-4460 * [6] chr2 6700-6850 * ------- seqinfo: 2 sequences from an unspecified genome; no seqlengths coverage() summarizes the times each base is covered by an interval coverage(gr) RleList of length 2 $chr1 integer-Rle of length 8100 with 6 runs Lengths: 1799 2101 1399 101 2499 201 Values : 0 1 0 1 0 1 $chr2 integer-Rle of length 6850 with 10 runs Lengths: 999 300 800 101 400 700 99 1061 2239 151 Values : 0 1 2 3 2 1 0 1 0 1 It is also possible to perform operations between two different GRanges objects. For instance, one may be interested in knowing the intervals that overlap with a targeted region: target &lt;- GRanges(seqnames=&quot;chr1&quot;, range=IRanges(start=1200, 4000)) target GRanges object with 1 range and 0 metadata columns: seqnames ranges strand &lt;Rle&gt; &lt;IRanges&gt; &lt;Rle&gt; [1] chr1 1200-4000 * ------- seqinfo: 1 sequence from an unspecified genome; no seqlengths gr.ov &lt;- findOverlaps(target, gr) gr.ov Hits object with 1 hit and 0 metadata columns: queryHits subjectHits &lt;integer&gt; &lt;integer&gt; [1] 1 2 ------- queryLength: 1 / subjectLength: 8 To recover the overlapping intervals between gr and target we can run gr[subjectHits(gr.ov)] GRanges object with 1 range and 2 metadata columns: seqnames ranges strand | disease gene_id &lt;Rle&gt; &lt;IRanges&gt; &lt;Rle&gt; | &lt;character&gt; &lt;character&gt; [1] chr1 1800-3900 - | Asthma Gene2 ------- seqinfo: 2 sequences from an unspecified genome; no seqlengths or subsetByOverlaps(gr, target) GRanges object with 1 range and 2 metadata columns: seqnames ranges strand | disease gene_id &lt;Rle&gt; &lt;IRanges&gt; &lt;Rle&gt; | &lt;character&gt; &lt;character&gt; [1] chr1 1800-3900 - | Asthma Gene2 ------- seqinfo: 2 sequences from an unspecified genome; no seqlengths Other operations can be found here. 2.2.5 RangedSummarizedExperiment SummarizedExperiment is extended to RangedSummarizedExperiment, a child class that contains the annotation data of the features in a GenomicRanges object. In our epigenomic example, the second most primitive class of brge_methy object with omic functionality, after SummarizedExperiment, is RangedSummarizedExperiment. Annotation data, with variable names given by names(rowData(brge_methy)) [1] &quot;Forward_Sequence&quot; &quot;SourceSeq&quot; [3] &quot;Random_Loci&quot; &quot;Methyl27_Loci&quot; [5] &quot;genes&quot; &quot;UCSC_RefGene_Accession&quot; [7] &quot;group&quot; &quot;Phantom&quot; [9] &quot;DMR&quot; &quot;Enhancer&quot; [11] &quot;HMM_Island&quot; &quot;Regulatory_Feature_Name&quot; [13] &quot;Regulatory_Feature_Group&quot; &quot;DHS&quot; can be obtained in a GRanges object, for a given variable. For instance, metadata of CpG genomic annotation and neighboring genes is obtained using array syntax rowRanges(brge_methy)[, &quot;genes&quot;] GRanges object with 392277 ranges and 1 metadata column: seqnames ranges strand | genes &lt;Rle&gt; &lt;IRanges&gt; &lt;Rle&gt; | &lt;character&gt; cg13869341 chr1 15865 * | WASH5P cg24669183 chr1 534242 * | cg15560884 chr1 710097 * | cg01014490 chr1 714177 * | cg17505339 chr1 720865 * | ... ... ... ... . ... cg04964672 chrY 7428198 * | cg01086462 chrY 7429349 * | cg02233183 chrY 16634382 * | NLGN4Y;NLGN4Y cg26251715 chrY 21236229 * | TTTY14 cg25640065 chrY 23569324 * | ------- seqinfo: 24 sequences from an unspecified genome; no seqlengths Subject data can be accessed entirely in a single data.frame or a variable at the time. The entire subject (phenotype) information is retrieved with the function colData(): colData(brge_methy) DataFrame with 20 rows and 9 columns age sex NK Bcell CD4T CD8T &lt;numeric&gt; &lt;factor&gt; &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; x0017 4 Female -5.81386e-19 0.1735078 0.20406869 0.1009741 x0043 4 Female 1.64826e-03 0.1820172 0.16171272 0.1287722 x0036 4 Male 1.13186e-02 0.1690173 0.15546368 0.1277417 x0041 4 Female 8.50822e-03 0.0697158 0.00732789 0.0321861 x0032 4 Male 0.00000e+00 0.1139780 0.22230399 0.0216090 ... ... ... ... ... ... ... x0018 4 Female 0.0170284 0.0781698 0.112735 0.06796816 x0057 4 Female 0.0000000 0.0797774 0.111072 0.00910489 x0061 4 Female 0.0000000 0.1640266 0.224203 0.13125212 x0077 4 Female 0.0000000 0.1122731 0.168056 0.07840593 x0079 4 Female 0.0120148 0.0913650 0.205830 0.11475389 Eos Mono Neu &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; x0017 0.00000e+00 0.0385654 0.490936 x0043 0.00000e+00 0.0499542 0.491822 x0036 0.00000e+00 0.1027105 0.459632 x0041 0.00000e+00 0.0718280 0.807749 x0032 2.60504e-18 0.0567246 0.575614 ... ... ... ... x0018 8.37770e-03 0.0579535 0.658600 x0057 4.61887e-18 0.1015260 0.686010 x0061 8.51074e-03 0.0382647 0.429575 x0077 6.13397e-02 0.0583411 0.515284 x0079 0.00000e+00 0.0750535 0.513597 The list symbol $ can be used, for instance, to obtain the sex of the individuals brge_methy$sex [1] Female Female Male Female Male Male Male Male Male [10] Male Female Female Female Male Male Female Female Female [19] Female Female Levels: Female Male Subsetting the entire structure is also possible following the usual array syntax. For example, we can select only males from the brge_methy dataset brge_methy[, brge_methy$sex == &quot;male&quot;] class: GenomicRatioSet dim: 392277 0 metadata(0): assays(1): Beta rownames(392277): cg13869341 cg24669183 ... cg26251715 cg25640065 rowData names(14): Forward_Sequence SourceSeq ... Regulatory_Feature_Group DHS colnames(0): colData names(9): age sex ... Mono Neu Annotation array: IlluminaHumanMethylation450k annotation: ilmn12.hg19 Preprocessing Method: NA minfi version: NA Manifest version: NA The metadata() function retrieves experimental data metadata(brge_methy) list() which in our case is empty. 2.3 Annotation 2.4 annotate package Bioconductor distributes annotation packages for a wide range of gene expression microarrays and RNA-seq data. The annotate package is one way to use this annotation information. This code loads the annotate package and the databases for the Gene Ontology and one of the Affymetrix human microarray chips. library(annotate) library(hgu95av2.db) library(GO.db) The databases are queried with get() or mget() for multiple queries: get(&quot;32972_at&quot;, envir=hgu95av2GENENAME) [1] &quot;NADPH oxidase 1&quot; mget(c(&quot;738_at&quot;, &quot;40840_at&quot;, &quot;32972_at&quot;), envir=hgu95av2GENENAME) $`738_at` [1] &quot;5&#39;-nucleotidase, cytosolic II&quot; $`40840_at` [1] &quot;peptidylprolyl isomerase F&quot; $`32972_at` [1] &quot;NADPH oxidase 1&quot; The name of the availabe information in a Bioconductor database (ended by .db, for instance org.Hs.eg.db) can be retreived by using columns(): columns(hgu95av2.db) [1] &quot;ACCNUM&quot; &quot;ALIAS&quot; &quot;ENSEMBL&quot; &quot;ENSEMBLPROT&quot; [5] &quot;ENSEMBLTRANS&quot; &quot;ENTREZID&quot; &quot;ENZYME&quot; &quot;EVIDENCE&quot; [9] &quot;EVIDENCEALL&quot; &quot;GENENAME&quot; &quot;GO&quot; &quot;GOALL&quot; [13] &quot;IPI&quot; &quot;MAP&quot; &quot;OMIM&quot; &quot;ONTOLOGY&quot; [17] &quot;ONTOLOGYALL&quot; &quot;PATH&quot; &quot;PFAM&quot; &quot;PMID&quot; [21] &quot;PROBEID&quot; &quot;PROSITE&quot; &quot;REFSEQ&quot; &quot;SYMBOL&quot; [25] &quot;UCSCKG&quot; &quot;UNIGENE&quot; &quot;UNIPROT&quot; The GO terms can be managed by go &lt;- get(&quot;738_at&quot;, envir=hgu95av2GO) names(go) [1] &quot;GO:0006195&quot; &quot;GO:0016311&quot; &quot;GO:0017144&quot; &quot;GO:0046040&quot; &quot;GO:0046085&quot; [6] &quot;GO:0005829&quot; &quot;GO:0000166&quot; &quot;GO:0005515&quot; &quot;GO:0008253&quot; &quot;GO:0046872&quot; get(&quot;GO:0009117&quot;, envir=GOTERM) GOID: GO:0009117 Term: nucleotide metabolic process Ontology: BP Definition: The chemical reactions and pathways involving a nucleotide, a nucleoside that is esterified with (ortho)phosphate or an oligophosphate at any hydroxyl group on the glycose moiety; may be mono-, di- or triphosphate; this definition includes cyclic nucleotides (nucleoside cyclic phosphates). Synonym: nucleotide metabolism There are multiple annotated databases in Bioconductor that can be found here: annotated data bases. For example require(org.Hs.eg.db) columns(org.Hs.eg.db) [1] &quot;ACCNUM&quot; &quot;ALIAS&quot; &quot;ENSEMBL&quot; &quot;ENSEMBLPROT&quot; [5] &quot;ENSEMBLTRANS&quot; &quot;ENTREZID&quot; &quot;ENZYME&quot; &quot;EVIDENCE&quot; [9] &quot;EVIDENCEALL&quot; &quot;GENENAME&quot; &quot;GO&quot; &quot;GOALL&quot; [13] &quot;IPI&quot; &quot;MAP&quot; &quot;OMIM&quot; &quot;ONTOLOGY&quot; [17] &quot;ONTOLOGYALL&quot; &quot;PATH&quot; &quot;PFAM&quot; &quot;PMID&quot; [21] &quot;PROSITE&quot; &quot;REFSEQ&quot; &quot;SYMBOL&quot; &quot;UCSCKG&quot; [25] &quot;UNIGENE&quot; &quot;UNIPROT&quot; # get the gene symbol get(&quot;9726&quot;, envir=org.Hs.egSYMBOL) [1] &quot;ZNF646&quot; 2.5 BioMart BioMart is a query-oriented data management system developed jointly by the European Bioinformatics Institute (EBI) and Cold Spring Harbor Laboratory (CSHL). biomaRt is an R interface to BioMart systems, in particular to Ensembl. Ensembl is a joint project between EMBL - European Bioinformatics Institute (EBI) and the Wellcome Trust Sanger Institute (WTSI) to develop a software system which produces and maintains automatic annotation on selected eukaryotic genomes. There are several databases that can be queried: require(biomaRt) head(listMarts()) biomart version 1 ENSEMBL_MART_ENSEMBL Ensembl Genes 101 2 ENSEMBL_MART_MOUSE Mouse strains 101 3 ENSEMBL_MART_SNP Ensembl Variation 101 4 ENSEMBL_MART_FUNCGEN Ensembl Regulation 101 After selecting a database (e.g., ensembl) we select a dataset: mart &lt;- useMart(biomart=&quot;ensembl&quot;) listDatasets(mart)[1:10,] dataset 1 acalliptera_gene_ensembl 2 acarolinensis_gene_ensembl 3 acchrysaetos_gene_ensembl 4 acitrinellus_gene_ensembl 5 amelanoleuca_gene_ensembl 6 amexicanus_gene_ensembl 7 ampachon_gene_ensembl 8 anancymaae_gene_ensembl 9 aplatyrhynchos_gene_ensembl 10 applatyrhynchos_gene_ensembl description 1 Eastern happy genes (fAstCal1.2) 2 Anole lizard genes (AnoCar2.0) 3 Golden eagle genes (bAquChr1.2) 4 Midas cichlid genes (Midas_v5) 5 Panda genes (ailMel1) 6 Mexican tetra genes (Astyanax_mexicanus-2.0) 7 Pachon cavefish genes (Astyanax_mexicanus-1.0.2) 8 Ma&#39;s night monkey genes (Anan_2.0) 9 Mallard genes (ASM874695v1) 10 Duck genes (CAU_duck1.0) version 1 fAstCal1.2 2 AnoCar2.0 3 bAquChr1.2 4 Midas_v5 5 ailMel1 6 Astyanax_mexicanus-2.0 7 Astyanax_mexicanus-1.0.2 8 Anan_2.0 9 ASM874695v1 10 CAU_duck1.0 After selecting a dataset (e.g., hsapiens_gene_ensembl) we select the attributes we are interested in: mart &lt;- useMart(biomart=&quot;ensembl&quot;, dataset=&quot;hsapiens_gene_ensembl&quot;) listAttributes(mart)[1:10,] name description 1 ensembl_gene_id Gene stable ID 2 ensembl_gene_id_version Gene stable ID version 3 ensembl_transcript_id Transcript stable ID 4 ensembl_transcript_id_version Transcript stable ID version 5 ensembl_peptide_id Protein stable ID 6 ensembl_peptide_id_version Protein stable ID version 7 ensembl_exon_id Exon stable ID 8 description Gene description 9 chromosome_name Chromosome/scaffold name 10 start_position Gene start (bp) page 1 feature_page 2 feature_page 3 feature_page 4 feature_page 5 feature_page 6 feature_page 7 feature_page 8 feature_page 9 feature_page 10 feature_page NOTE: sometimes the host is not working. If so, try host=“www.ensembl.org” in the useMart function. After selecting the dataset we can make different types of queries: Query 1: We could look for all the transcripts contained in the gene 7791 (entrez id): tx &lt;- getBM(attributes=&quot;ensembl_transcript_id&quot;, filters=&quot;entrezgene_id&quot;, values=&quot;7791&quot;, mart=mart) tx ensembl_transcript_id 1 ENST00000322764 2 ENST00000449630 3 ENST00000468083 4 ENST00000457235 5 ENST00000354434 6 ENST00000392910 7 ENST00000477373 8 ENST00000436448 9 ENST00000446634 10 ENST00000497119 11 ENST00000644808 12 ENST00000644767 13 ENST00000645428 14 ENST00000643962 15 ENST00000642783 16 ENST00000644791 17 ENST00000647142 18 ENST00000645637 19 ENST00000646695 20 ENST00000647126 Query 2: We could look for chromosome, position and gene name of a list of genes (entrez id): genes &lt;- c(&quot;79699&quot;, &quot;7791&quot;, &quot;23140&quot;, &quot;26009&quot;) tx &lt;- getBM(attributes=c(&quot;chromosome_name&quot;, &quot;start_position&quot;, &quot;hgnc_symbol&quot;), filters=&quot;entrezgene_id&quot;, values=genes, mart=mart) tx chromosome_name start_position hgnc_symbol 1 17 4004445 ZZEF1 2 1 77562416 ZZZ3 3 7 143381295 ZYX 4 CHR_HG708_PATCH 143381295 ZYX 5 1 52726453 ZYG11B Query 3: We could look for chromosome, position and gene name of a list of genes (ENSEMBL): genes &lt;- c(&quot;ENSG00000074755&quot;) tx &lt;- getBM(attributes=c(&quot;chromosome_name&quot;, &quot;start_position&quot;, &quot;hgnc_symbol&quot;), filters=&quot;ensembl_gene_id&quot;, values=genes, mart=mart) tx chromosome_name start_position hgnc_symbol 1 17 4004445 ZZEF1 Query 4: Homology. getLDS() combines two data marts, for example to homologous genes in other species. We can look up the mouse equivalents of a particular Affy transcript, or of the NOX1 gene. human &lt;- useMart(&quot;ensembl&quot;, dataset = &quot;hsapiens_gene_ensembl&quot;) mouse &lt;- useMart(&quot;ensembl&quot;, dataset = &quot;mmusculus_gene_ensembl&quot;) getLDS(attributes = c(&quot;hgnc_symbol&quot;,&quot;chromosome_name&quot;, &quot;start_position&quot;), filters = &quot;hgnc_symbol&quot;, values = &quot;NOX1&quot;, mart = human, attributesL = c(&quot;external_gene_name&quot;, &quot;chromosome_name&quot;, &quot;start_position&quot;), martL = mouse) HGNC.symbol Chromosome.scaffold.name Gene.start..bp. Gene.name 1 NOX1 X 100843324 Nox1 Chromosome.scaffold.name.1 Gene.start..bp..1 1 X 134086421 2.6 Annotate SNPs We had a set of 100 SNPs without chromosome and genomic position information. We need to know the gene that those SNPs belong to. load(&quot;data/snpsList.Rdata&quot;) length(snpsList) [1] 100 head(snpsList) [1] &quot;rs1932919&quot; &quot;rs6849766&quot; &quot;rs11246756&quot; &quot;rs7184849&quot; &quot;rs308857&quot; [6] &quot;rs16990309&quot; A hand-search (Genome Browser - ) would be easy but tedious, so we want an automated approach. R can be used to carry out the entire analysis. That is, GWAS, annotation and post-GWAS. The annotation can be set by connecting R with Biomart: snpmart &lt;- useMart(&quot;ENSEMBL_MART_SNP&quot;, dataset = &quot;hsapiens_snp&quot;) Use listAttributes() to get valid attribute names. Use listFilters() to get valid filter names. head(listAttributes(snpmart)) name description 1 refsnp_id Variant name 2 refsnp_source Variant source 3 refsnp_source_description Variant source description 4 chr_name Chromosome/scaffold name 5 chrom_start Chromosome/scaffold position start (bp) 6 chrom_end Chromosome/scaffold position end (bp) page 1 snp 2 snp 3 snp 4 snp 5 snp 6 snp head(listFilters(snpmart)) name description 1 chr_name Chromosome/scaffold name 2 start Start 3 end End 4 band_start Band Start 5 band_end Band End 6 marker_start Marker Start We can retrieve chromosome name, genomic position and reference allele in 1000 Genome Project of the ‘significant SNPs’ (provided in out list) by: snpInfo &lt;- getBM(c(&quot;refsnp_id&quot;, &quot;chr_name&quot;, &quot;chrom_start&quot;, &quot;allele&quot;), filters = c(&quot;snp_filter&quot;), values = snpsList, mart = snpmart) head(snpInfo) refsnp_id chr_name chrom_start allele 1 rs294611 3 14801351 T/C 2 rs485141 1 76618179 C/A/G 3 rs419655 1 24986471 T/A/C 4 rs680017 1 99202181 A/G 5 rs6439924 3 140450815 A/C 6 rs2125230 1 243722546 G/A How do we annotate this SNPs into genes? Fist, transform SNP annotation into a GenomicRange snpsInfo.gr &lt;- makeGRangesFromDataFrame(snpInfo, start.field=&quot;chrom_start&quot;, keep.extra.columns = TRUE, seqnames.field = &quot;chr_name&quot;, end.field = &quot;chrom_start&quot;) snpsInfo.gr GRanges object with 101 ranges and 2 metadata columns: seqnames ranges strand | refsnp_id allele &lt;Rle&gt; &lt;IRanges&gt; &lt;Rle&gt; | &lt;character&gt; &lt;character&gt; [1] 3 14801351 * | rs294611 T/C [2] 1 76618179 * | rs485141 C/A/G [3] 1 24986471 * | rs419655 T/A/C [4] 1 99202181 * | rs680017 A/G [5] 3 140450815 * | rs6439924 A/C ... ... ... ... . ... ... [97] X 64333971 * | rs1932919 C/T [98] X 101998212 * | rs5944928 C/T [99] X 151640975 * | rs12861395 A/G/T [100] 9 135028063 * | rs7025267 G/A [101] 9 37418938 * | rs10814535 C/G/T ------- seqinfo: 25 sequences from an unspecified genome; no seqlengths Then, the genes corresponding to those variants can be obtained by using VariantAnnotation package and TxDb.Hsapiens.UCSC.hg10.knownGene annotation package that contains the annotated genes from UCSC in hg19 assembly. However, we need first to verify that the seqnames (e.g chromosome names) are the ones available in the reference genome seqnames(snpsInfo.gr) factor-Rle of length 101 with 37 runs Lengths: 1 3 1 ... 4 3 2 Values : 3 1 3 ... 8 X 9 Levels(25): CHR_HSCHR1_3_CTG32_1 CHR_HSCHR22_1_CTG6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 X We see that the annotation is not in the UCSC format (it uses NCBI), so this should be changed seqlevelsStyle(snpsInfo.gr) &lt;- &quot;UCSC&quot; Then, we just keep the autosomes and sexual chromosomes seqlevels(snpsInfo.gr, pruning.mode=&quot;coarse&quot;) &lt;- paste0(&quot;chr&quot;, c(1:22, &quot;X&quot;, &quot;Y&quot;)) We can obtain annotation for coding regions library(VariantAnnotation) library(TxDb.Hsapiens.UCSC.hg19.knownGene) coding &lt;- locateVariants(snpsInfo.gr, TxDb.Hsapiens.UCSC.hg19.knownGene, CodingVariants()) coding GRanges object with 3 ranges and 9 metadata columns: seqnames ranges strand | LOCATION LOCSTART LOCEND QUERYID TXID CDSID GENEID PRECEDEID FOLLOWID &lt;Rle&gt; &lt;IRanges&gt; &lt;Rle&gt; | &lt;factor&gt; &lt;integer&gt; &lt;integer&gt; &lt;integer&gt; &lt;character&gt; &lt;IntegerList&gt; &lt;character&gt; &lt;CharacterList&gt; &lt;CharacterList&gt; [1] chr21 19755999 - | coding 441 441 39 73044 213015 5651 [2] chr11 4626540 - | coding 195 195 70 43412 128591 55128 [3] chr11 4626540 - | coding 195 195 70 43414 128591 55128 ------- seqinfo: 24 sequences from an unspecified genome; no seqlengths or for all regions allvar &lt;- locateVariants(snpsInfo.gr, TxDb.Hsapiens.UCSC.hg19.knownGene, AllVariants()) allvar GRanges object with 194 ranges and 9 metadata columns: seqnames ranges strand | LOCATION LOCSTART LOCEND QUERYID TXID CDSID GENEID &lt;Rle&gt; &lt;IRanges&gt; &lt;Rle&gt; | &lt;factor&gt; &lt;integer&gt; &lt;integer&gt; &lt;integer&gt; &lt;character&gt; &lt;IntegerList&gt; &lt;character&gt; [1] chr3 14801351 + | intron 82050 82050 1 13302 84077 [2] chr3 14801351 + | intron 82552 82552 1 13303 84077 [3] chr3 14801351 + | intron 82447 82447 1 13304 84077 [4] chr3 14801351 + | intron 44260 44260 1 13305 84077 [5] chr3 14801351 + | intron 2170 2170 1 13306 84077 ... ... ... ... . ... ... ... ... ... ... ... [190] chrX 101998212 + | intron 22392 22392 96 76301 80823 [191] chrX 101998212 + | intron 22324 22324 96 76302 80823 [192] chrX 151640975 * | intergenic &lt;NA&gt; &lt;NA&gt; 97 &lt;NA&gt; &lt;NA&gt; [193] chr9 135028063 * | intergenic &lt;NA&gt; &lt;NA&gt; 98 &lt;NA&gt; &lt;NA&gt; [194] chr9 37418938 * | intergenic &lt;NA&gt; &lt;NA&gt; 99 &lt;NA&gt; &lt;NA&gt; PRECEDEID FOLLOWID &lt;CharacterList&gt; &lt;CharacterList&gt; [1] [2] [3] [4] [5] ... ... ... [190] [191] [192] 100130935,100287428,100287466,... 100533997,1260,139135,... [193] 1056,1057,11092,... 10585,26786,286336,... [194] 158234,219,22844,... 100506710,100616278,100616289,... ------- seqinfo: 24 sequences from an unspecified genome; no seqlengths We can see the distribution of the location of our variants table(allvar$LOCATION) spliceSite intron fiveUTR threeUTR coding intergenic promoter 0 129 0 4 3 57 1 Finally, we can get the gene symbol by library(org.Hs.eg.db) # to know the type of ID in the Human TxDb TxDb.Hsapiens.UCSC.hg19.knownGene TxDb object: # Db type: TxDb # Supporting package: GenomicFeatures # Data source: UCSC # Genome: hg19 # Organism: Homo sapiens # Taxonomy ID: 9606 # UCSC Table: knownGene # Resource URL: http://genome.ucsc.edu/ # Type of Gene ID: Entrez Gene ID # Full dataset: yes # miRBase build ID: GRCh37 # transcript_nrow: 82960 # exon_nrow: 289969 # cds_nrow: 237533 # Db created by: GenomicFeatures package from Bioconductor # Creation time: 2015-10-07 18:11:28 +0000 (Wed, 07 Oct 2015) # GenomicFeatures version at creation time: 1.21.30 # RSQLite version at creation time: 1.0.0 # DBSCHEMAVERSION: 1.1 # to know the accesors (&#39;variables) keytypes(org.Hs.eg.db) [1] &quot;ACCNUM&quot; &quot;ALIAS&quot; &quot;ENSEMBL&quot; &quot;ENSEMBLPROT&quot; &quot;ENSEMBLTRANS&quot; &quot;ENTREZID&quot; &quot;ENZYME&quot; &quot;EVIDENCE&quot; &quot;EVIDENCEALL&quot; [10] &quot;GENENAME&quot; &quot;GO&quot; &quot;GOALL&quot; &quot;IPI&quot; &quot;MAP&quot; &quot;OMIM&quot; &quot;ONTOLOGY&quot; &quot;ONTOLOGYALL&quot; &quot;PATH&quot; [19] &quot;PFAM&quot; &quot;PMID&quot; &quot;PROSITE&quot; &quot;REFSEQ&quot; &quot;SYMBOL&quot; &quot;UCSCKG&quot; &quot;UNIGENE&quot; &quot;UNIPROT&quot; # to make the call (be careful with other packages having select()) keys &lt;- allvar$GENEID genes &lt;- AnnotationDbi::select(org.Hs.eg.db, columns=&quot;SYMBOL&quot;, key=keys, keytype=&quot;ENTREZID&quot;) # to add to the GRanges allvar$Symbol &lt;- genes$SYMBOL allvar GRanges object with 194 ranges and 10 metadata columns: seqnames ranges strand | LOCATION LOCSTART LOCEND QUERYID TXID CDSID GENEID &lt;Rle&gt; &lt;IRanges&gt; &lt;Rle&gt; | &lt;factor&gt; &lt;integer&gt; &lt;integer&gt; &lt;integer&gt; &lt;character&gt; &lt;IntegerList&gt; &lt;character&gt; [1] chr3 14801351 + | intron 82050 82050 1 13302 84077 [2] chr3 14801351 + | intron 82552 82552 1 13303 84077 [3] chr3 14801351 + | intron 82447 82447 1 13304 84077 [4] chr3 14801351 + | intron 44260 44260 1 13305 84077 [5] chr3 14801351 + | intron 2170 2170 1 13306 84077 ... ... ... ... . ... ... ... ... ... ... ... [190] chrX 101998212 + | intron 22392 22392 96 76301 80823 [191] chrX 101998212 + | intron 22324 22324 96 76302 80823 [192] chrX 151640975 * | intergenic &lt;NA&gt; &lt;NA&gt; 97 &lt;NA&gt; &lt;NA&gt; [193] chr9 135028063 * | intergenic &lt;NA&gt; &lt;NA&gt; 98 &lt;NA&gt; &lt;NA&gt; [194] chr9 37418938 * | intergenic &lt;NA&gt; &lt;NA&gt; 99 &lt;NA&gt; &lt;NA&gt; PRECEDEID FOLLOWID Symbol &lt;CharacterList&gt; &lt;CharacterList&gt; &lt;character&gt; [1] C3orf20 [2] C3orf20 [3] C3orf20 [4] C3orf20 [5] C3orf20 ... ... ... ... [190] BHLHB9 [191] BHLHB9 [192] 100130935,100287428,100287466,... 100533997,1260,139135,... &lt;NA&gt; [193] 1056,1057,11092,... 10585,26786,286336,... &lt;NA&gt; [194] 158234,219,22844,... 100506710,100616278,100616289,... &lt;NA&gt; ------- seqinfo: 24 sequences from an unspecified genome; no seqlengths References "],
["single-association-analysis.html", "3 Single association analysis 3.1 Descriptive analysis 3.2 Hardy-Weinberg equilibrium 3.3 Single SNP association analysis 3.4 Gene-environment and gene-gene interactions 3.5 Haplotype analysis 3.6 Genetic score", " 3 Single association analysis Genetic association studies aim to identify genetic variants that explain subject differences in qualitative or quantitative traits. Genetic variants may include SNPs, CNVs, mosaicisms or polymorphic inversions, which can be obtained from SNP array. In this chapter, we thoroughly discuss SNP association studies. We explain the different genetic models to be used in single SNP associations and how they are applied in a massive univariate testing when several SNPs are analyzed. Relating the simultaneous analysis of multiple SNPs, we discuss haplotype and genetic scores associations 3.1 Descriptive analysis SNP data are typically available in text format or Excel spreadsheets which are easily uploaded in R as a data frame. Here, as an illustrative example, we are analyzing a dataset containing epidemiological information and 51 SNPs from a case-control study on asthma. The data is loaded into the R session by asthma &lt;- read.delim(&quot;data/asthma.txt&quot;) str(asthma, list.len=9) &#39;data.frame&#39;: 1578 obs. of 57 variables: $ country : chr &quot;Germany&quot; &quot;Germany&quot; &quot;Germany&quot; &quot;Germany&quot; ... $ gender : chr &quot;Males&quot; &quot;Males&quot; &quot;Males&quot; &quot;Females&quot; ... $ age : num 42.8 50.2 46.7 47.9 48.4 ... $ bmi : num 20.1 24.7 27.7 33.3 25.2 ... $ smoke : int 2 0 1 1 0 2 1 0 0 0 ... $ casecontrol: int 0 0 0 0 1 0 0 0 0 0 ... $ rs4490198 : chr &quot;GG&quot; &quot;GG&quot; &quot;GG&quot; &quot;AG&quot; ... $ rs4849332 : chr &quot;TT&quot; &quot;GT&quot; &quot;TT&quot; &quot;GT&quot; ... $ rs1367179 : chr &quot;GC&quot; &quot;GC&quot; &quot;GC&quot; &quot;GG&quot; ... [list output truncated] asthma[1:5, 1:8] country gender age bmi smoke casecontrol rs4490198 1 Germany Males 42.80630 20.14797 2 0 GG 2 Germany Males 50.22861 24.69136 0 0 GG 3 Germany Males 46.68857 27.73230 1 0 GG 4 Germany Females 47.86311 33.33187 1 0 AG 5 Germany Females 48.44079 25.23634 0 1 AG rs4849332 1 TT 2 GT 3 TT 4 GT 5 GG We observe that we have case-control status (0: control, 1: asthma) and another 4 variables encoding the country of origin, gender, age, body mass index (bmi) and smoking status (0: no smoker, 1: ex-smoker, 2: current smoker). There are 51 SNPs whose genotypes are given by the alleles names. To start the analysis, we must indicate which columns of the dataset asthma contain the SNP data, using the setupSNP function. In our example, SNPs start from column 7 onwards, which we specify in argument colSNPs library(SNPassoc) asthma.s &lt;- setupSNP(data=asthma, colSNPs=7:ncol(asthma), sep=&quot;&quot;) This is an alternative way of determining the columns containing the SNPs idx &lt;- grep(&quot;^rs&quot;, colnames(asthma)) asthma.s &lt;- setupSNP(data=asthma, colSNPs=idx, sep=&quot;&quot;) The argument sep indicates the character separating the alleles. The default value is ’‘/´´. In our case, there is no separating character, so that, we set sep=\"\". The argument name.genotypes can be used when genotypes are available in other formats, such as 0, 1, 2 or’‘norm´´,’‘het´´,’’mut´´. The purpose of the setupSNP function is to assign the class snp to the SNPs variables, to which SNPassoc methods will be applied. The function labels the most common genotype across subjects as the reference one. When numerous SNPs are available, the function can be parallelized through the argument mc.cores that indicates the number of processors to be used. We can verify that the SNP variables are given the new class snp head(asthma.s$rs1422993) [1] G/G G/T G/G G/T G/T G/G Genotypes: G/G G/T T/T Alleles: G T class(asthma.s$rs1422993) [1] &quot;snp&quot; &quot;factor&quot; and summarize their content with summary summary(asthma.s$rs1422993) Genotypes: frequency percentage G/G 903 57.224335 G/T 570 36.121673 T/T 105 6.653992 Alleles: frequency percentage G 2376 75.28517 T 780 24.71483 HWE (p value): 0.250093 which shows the genotype and allele frequencies for a given SNP, testing for Hardy-Weinberg equilibrium (HWE). We can also visualize the results in a plot by plot(asthma.s$rs1422993) Figure 3.1: SNP summary. Bar chart showing the basic information of a given SNP The argument type helps to get a pie chart plot(asthma.s$rs1422993, type=pie) Figure 3.2: SNP summary. Pie chart showing the basic information of a given SNP The summary function can also be applied to the whole dataset summary(asthma.s, print=FALSE) alleles major.allele.freq HWE missing (%) rs4490198 A/G 59.2 0.174133 0.6 rs4849332 G/T 61.8 0.522060 0.1 rs1367179 G/C 81.4 0.738153 1.0 rs11123242 C/T 81.7 0.932898 0.6 rs13014858 G/A 58.3 0.351116 0.1 rs1430094 G/A 66.9 0.305509 0.4 rs1430093 C/A 66.6 0.817701 3.5 rs746710 G/C 51.5 0.614368 0.0 rs1430090 T/G 70.0 0.025180 1.6 rs6737251 C/T 69.3 0.235996 0.3 rs11685217 C/T 80.1 0.009462 4.5 rs1430097 C/A 65.1 0.738166 1.0 rs10496465 A/G 85.8 0.917997 0.6 rs3756688 T/C 63.9 0.154632 0.6 rs2303063 A/G 53.0 0.722069 1.1 rs1422993 G/T 75.3 0.250093 0.0 rs2400478 G/A 62.6 0.256786 0.9 rs714588 A/G 54.9 0.838329 0.8 rs1023555 T/A 76.8 0.943443 0.5 rs898070 G/A 62.6 1.000000 0.6 rs963218 C/T 53.2 0.389387 0.3 rs1419835 C/T 78.2 0.505391 0.6 rs765023 T/C 64.5 0.030513 6.9 rs1345267 A/G 61.0 0.112183 0.1 rs324381 G/A 64.6 0.242223 11.6 rs184448 T/G 55.9 0.008446 2.2 rs324396 C/T 71.2 0.197291 0.3 rs324957 G/A 57.0 0.007417 0.4 rs324960 C/T 66.6 0.077777 1.1 rs10486657 C/T 81.3 0.672703 4.3 rs324981 A/T 53.2 0.048438 0.2 rs1419780 C/G 80.8 0.569652 0.2 rs325462 T/A 51.0 0.337862 0.3 rs727162 G/C 78.5 0.765708 0.0 rs10250709 G/A 65.4 0.266434 0.0 rs6958905 T/C 64.7 0.377472 0.4 rs10238983 T/C 75.7 0.216435 0.4 rs4941643 A/G 54.1 0.635887 7.2 rs3794381 C/G 71.7 0.652089 7.1 rs2031532 G/A 65.0 0.911918 0.0 rs2247119 T/C 71.5 0.457710 0.5 rs8000149 T/C 63.2 0.588077 0.4 rs2274276 G/C 57.0 0.571386 0.6 rs7332573 G/T 91.5 0.869947 1.5 rs3829366 T/A 51.6 0.722626 1.3 rs6084432 G/A 83.7 0.266716 0.6 rs512625 G/A 69.5 0.905395 0.4 rs3918395 G/T 86.8 0.508732 1.2 rs2787095 G/C 60.2 0.102053 0.8 rs2853215 G/A 73.0 0.249516 0.2 showing the SNP labels with minor/major allele format, the major allele frequency the HWE test and the percentage of missing genotypes. Missing values can be further explored plotting with plotMissing(asthma.s, print.labels.SNPs = FALSE) Figure 3.3: Missing genotypes. Black squares shows missing genotuype information of asthma data example. This plot can be used to inspect if missing values appear randomly across individuals and SNPs. In our case, we can see that the missing pattern may be considered random, except for three clusters in consecutive SNPs (large black squares). These individuals should be further checked for possible problems with genotyping. 3.2 Hardy-Weinberg equilibrium Genotyping of SNPs needs to pass quality control measures. Aside from technical details that need to be considered for filtering SNPs with low quality, genotype calling error can be detected by a HWE test. The test compares the observed genotype frequencies with those expected under random mating, which follows when the SNPs are in the absence of selection, mutation, genetic drift, or other forces. Therefore, HWE must be checked only in controls. There are several tests described in the literature to verify HWE. In SNPassoc HWE is tested for all the bi-allelic SNP markers using a fast exact test (Wigginton, Cutler, and Abecasis 2005) implemented in the tableHWE function. hwe &lt;- tableHWE(asthma.s) head(hwe) HWE (p value) rs4490198 0.1741325 rs4849332 0.5220596 rs1367179 0.7381531 rs11123242 0.9328981 rs13014858 0.3511162 rs1430094 0.3055089 We observe that the first SNPs in the dataset are under HWE since their P-values rejecting the HWE hypothesis (null hypothesis) are larger than 0.05. However, when tested in control samples only, by stratifying by cases and controls hwe2 &lt;- tableHWE(asthma.s, casecontrol) #SNPs is HWE in the whole sample but not controls snpNHWE &lt;- hwe2[,1]&gt;0.05 &amp; hwe2[,2]&lt;0.05 rownames(hwe2)[snpNHWE] [1] &quot;rs1345267&quot; hwe2[snpNHWE,] all groups 0 1 0.11218285 0.04956349 0.81604706 We see that rs1345267 is not in HWE within controls because its P-value is &lt;0.05. Notice that one is interested in keeping those SNPsthat do not reject the null hypothesis. As several SNPs are tested, multiple comparisons must be considered. In this particular setting, a threshold of 0.001 is normally considered. As a quality control measure, it is not necessary to be as conservative as in those situations where false discovery rates need to be controlled. SNPs that do not pass the HWE test must be removed form further analyses. We can recall setupSNP and indicate the columns of the SNPs to be kept snps.ok &lt;- rownames(hwe2)[hwe2[,2]&gt;=0.001] pos &lt;- which(colnames(asthma)%in%snps.ok, useNames = FALSE) asthma.s &lt;- setupSNP(asthma, pos, sep=&quot;&quot;) Note that in the variable pos we redefine the SNP variables to be considered as class snp. 3.3 Single SNP association analysis We are interested in finding those SNPs associated with asthma status that is encoded in the variable casecontrol. We first illustrate the association between case-control status and the SNP rs1422993. The association analysis for all genetic models is performed by the function association that regresses casecontrol on the variable rs1422993 from the dataset asthma.s that already contains the SNP variables of class snp. association(casecontrol ~ rs1422993, data = asthma.s) SNP: rs1422993 adjusted by: 0 % 1 % OR lower upper p-value AIC Codominant G/G 730 59.0 173 50.9 1.00 0.017768 1642 G/T 425 34.3 145 42.6 1.44 1.12 1.85 T/T 83 6.7 22 6.5 1.12 0.68 1.84 Dominant G/G 730 59.0 173 50.9 1.00 0.007826 1642 G/T-T/T 508 41.0 167 49.1 1.39 1.09 1.77 Recessive G/G-G/T 1155 93.3 318 93.5 1.00 0.877863 1649 T/T 83 6.7 22 6.5 0.96 0.59 1.57 Overdominant G/G-T/T 813 65.7 195 57.4 1.00 0.005026 1641 G/T 425 34.3 145 42.6 1.42 1.11 1.82 log-Additive 0,1,2 1238 78.5 340 21.5 1.22 1.01 1.47 0.040151 1644 The function association follows the usual syntax of R modelling functions with the difference that the variables in the model that are of class snp are tested using different genetic models. In our example, we observe that all genetic models but the recessive one are statistically significant. association also fits the overdominant model, which compares the two homozygous genotypes versus the heterozygous one. This genetic model of inheritance is biologically rare although it has been linked to sickle cell anemia in humans. The result table describes the number of individuals in each genotype across cases and controls. The ORs and CI-95% are also computed. The last column describes the AIC (Akaike information criteria) that can be used to decide which is the best model of inheritance; the lower the better the model is. In the example, one may conclude that rs1422993 is associated with asthma and that, for instance, the risk of being asthmatic is 39% higher in people having at least one alternative allele (T) with respect to individuals having none (dominant model). This risk is statistically significant since the CI-95% does not contain 1, the P-value is 0.0078&lt;0.022, or the P-value of the max-statistics is 0.01 maxstat(asthma.s$casecontrol, asthma.s$rs1422993) dominant recessive log-additive MAX-statistic Pr(&gt;z) [1,] 7.073 0.024 4.291 7.073 0.0166 * --- Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 If an expected model of inheritance is hypothesized, the association analysis for the model can be specified in the argument model, which by default test all models, association(casecontrol ~ rs1422993, asthma.s, model=&quot;dominant&quot;) SNP: rs1422993 adjusted by: 0 % 1 % OR lower upper p-value AIC Dominant G/G 730 59 173 50.9 1.00 0.007826 1642 G/T-T/T 508 41 167 49.1 1.39 1.09 1.77 Association tests are typically adjusted by covariates, which are incorporated in the model in the usual form association(casecontrol ~ rs1422993 + country + smoke, asthma.s) SNP: rs1422993 adjusted by: country smoke 0 % 1 % OR lower upper p-value AIC Codominant G/G 728 59.1 173 51.0 1.00 0.06957 1407 G/T 423 34.3 144 42.5 1.38 1.05 1.82 T/T 81 6.6 22 6.5 1.07 0.62 1.85 Dominant G/G 728 59.1 173 51.0 1.00 0.03380 1406 G/T-T/T 504 40.9 166 49.0 1.33 1.02 1.73 Recessive G/G-G/T 1151 93.4 317 93.5 1.00 0.80821 1411 T/T 81 6.6 22 6.5 0.94 0.55 1.60 Overdominant G/G-T/T 809 65.7 195 57.5 1.00 0.02163 1406 G/T 423 34.3 144 42.5 1.37 1.05 1.79 log-Additive 0,1,2 1232 78.4 339 21.6 1.19 0.96 1.46 0.10926 1408 ORs for stratified analysis on given categorical covariates are used to verify whether the risk is constant across groups association(casecontrol ~ rs1422993 + survival::strata(gender), asthma.s) SNP: rs1422993 adjusted by: survival::strata(gender) 0 % 1 % OR lower upper p-value AIC Codominant G/G 730 59.0 173 50.9 1.00 0.022940 1634 G/T 425 34.3 145 42.6 1.42 1.11 1.83 T/T 83 6.7 22 6.5 1.09 0.66 1.80 Dominant G/G 730 59.0 173 50.9 1.00 0.011144 1633 G/T-T/T 508 41.0 167 49.1 1.37 1.07 1.74 Recessive G/G-G/T 1155 93.3 318 93.5 1.00 0.805330 1640 T/T 83 6.7 22 6.5 0.94 0.58 1.53 Overdominant G/G-T/T 813 65.7 195 57.4 1.00 0.006378 1632 G/T 425 34.3 145 42.6 1.41 1.10 1.80 log-Additive 0,1,2 1238 78.5 340 21.5 1.21 1.00 1.46 0.055231 1636 We can see, for instance, that the dominant model is significant only in males. The subset argument allows fitting the model in a subgroup of individuals association(casecontrol ~ rs1422993, asthma.s, subset=country==&quot;Spain&quot;) SNP: rs1422993 adjusted by: 0 % 1 % OR lower upper p-value AIC Codominant G/G 179 54.6 22 44.9 1.00 0.3550 295.2 G/T 125 38.1 24 49.0 1.56 0.84 2.91 T/T 24 7.3 3 6.1 1.02 0.28 3.66 Dominant G/G 179 54.6 22 44.9 1.00 0.2059 293.7 G/T-T/T 149 45.4 27 55.1 1.47 0.81 2.70 Recessive G/G-G/T 304 92.7 46 93.9 1.00 0.7576 295.2 T/T 24 7.3 3 6.1 0.83 0.24 2.85 Overdominant G/G-T/T 203 61.9 25 51.0 1.00 0.1502 293.2 G/T 125 38.1 24 49.0 1.56 0.85 2.85 log-Additive 0,1,2 328 87.0 49 13.0 1.23 0.77 1.96 0.3816 294.5 These analyses can be also be performed in quantitative traits, such as body mass index, since association function automatically selects the error distribution of the regression analysis (either Gaussian or binomial). association(bmi ~ rs1422993, asthma.s) SNP: rs1422993 adjusted by: n me se dif lower upper p-value AIC Codominant G/G 896 25.53 0.1446 0.000000 0.9069 9069 G/T 565 25.50 0.1834 -0.027059 -0.4874 0.4332 T/T 105 25.71 0.4676 0.178076 -0.7057 1.0619 Dominant G/G 896 25.53 0.1446 0.000000 0.9818 9067 G/T-T/T 670 25.54 0.1710 0.005089 -0.4324 0.4426 Recessive G/G-G/T 1461 25.52 0.1135 0.000000 0.6694 9067 T/T 105 25.71 0.4676 0.188540 -0.6769 1.0540 Overdominant G/G-T/T 1001 25.55 0.1383 0.000000 0.8424 9067 G/T 565 25.50 0.1834 -0.045739 -0.4965 0.4050 log-Additive 0,1,2 0.033951 -0.3153 0.3832 0.8489 9067 For BMI, association tests whether the difference between means is statistically significant, rather than computing an OR. For multiple SNP data, our objective is to identify the variants that are significantly associated with the trait. The most basic strategy is, therefore, to fit an association test like the one described above for each of the SNPs in the dataset and determine which of those associations are significant. The massive univariate testing is the most widely used analysis method for omic data because of its simplicity. In SNPassoc, this type of analysis is done with the function WGassociation ans &lt;- WGassociation(casecontrol, data=asthma.s) head(ans) comments codominant dominant recessive overdominant rs4490198 - 0.52765 0.29503 0.96400 0.29998 rs4849332 - 0.96912 0.92986 0.84806 0.82327 rs1367179 - 0.62775 0.59205 0.35786 0.86419 rs11123242 - 0.68622 0.67596 0.39801 0.92878 rs13014858 - 0.52578 0.26739 0.88011 0.34966 rs1430094 - 0.13375 0.10569 0.54432 0.04490 log-additive rs4490198 0.49506 rs4849332 0.97049 rs1367179 0.43994 rs11123242 0.52009 rs13014858 0.40897 rs1430094 0.36611 Here, only the outcome is required in the formula argument (first argument) since the function successively calls association on each of the variables of class snp within data. The function returns the P-values of association of each SNP under each genetic model. Covariates can also be introduced in the model ans.adj &lt;- WGassociation(casecontrol ~ country + smoke, asthma.s) head(ans.adj) SNPassoc is computationally limited on large genomic data. The computing time can be reduced by parallelization, specifying in the argument mc.cores the number of computing cores to be used. Alternatively, the function scanWGassociation, a C compiled function, can be used to compute a predetermined genetic model across all SNPs, passed in the argument model, which by default is the additive model ans.fast &lt;- scanWGassociation(casecontrol, asthma.s) NOTE: This function is not available on the SNPassoc version available on CRAN. The user can install the development version available on GitHub to get access to this function just executing devtools::install_github(&quot;isglobal-brge/SNPassoc&quot;) The P-values obtained from massive univariate analyses are visualized with the generic plot function plot(ans) Figure 3.4: Manhattan-type plots for different genetic models. P-values in -log10 scale to assess the association between case-control status and SNPs in the asthma example. This produces a Manhattan plot of the -log10(P-values) for all the SNPs over all models. It shows the nominal level of significance and the Bonferroni level, which is the level corrected by the multiple testing across all SNPs. The overall hypothesis of massive univariate association tests is whether there is any SNP that is significantly associated with the phenotype. As multiple SNPs are tested, the probability of finding at least one significant finding increases if we do not lower the significance threshold. The Bonferroni correction lowers the threshold by the number of SNPs tested (0.0001=0.05/51). In the Manhattan plotof our analysis, we see that no SNP is significant at the Bonferroni level, and therefore there is no SNP that is significantly associated with asthma. Maximum-statistic (see González et al. 2008) can also be used to test association between asthma status and SNPs ans.max &lt;- maxstat(asthma.s, casecontrol) ans.max dominant recessive log-additive MAX-statistic Pr(&gt;z) rs4490198 1.097 0.002 0.466 1.097 0.50189 rs4849332 0.008 0.037 0.001 0.037 0.97609 rs1367179 0.287 0.845 0.602 0.845 0.58888 rs11123242 0.175 0.714 0.417 0.714 0.63964 rs13014858 1.230 0.023 0.683 1.230 0.46295 rs1430094 2.617 0.368 0.821 2.617 0.20673 rs1430093 1.051 0.042 0.743 1.051 0.51864 rs746710 0.728 0.679 1.051 1.051 0.51628 rs1430090 0.172 0.463 0.000 0.463 0.74308 rs6737251 0.143 0.156 0.217 0.217 0.86919 rs11685217 0.894 0.030 0.705 0.894 0.56883 rs1430097 0.003 0.183 0.029 0.183 0.88853 rs10496465 0.003 0.020 0.008 0.020 0.98739 rs3756688 0.016 0.738 0.266 0.738 0.62640 rs2303063 0.060 1.271 0.658 1.271 0.45273 rs1422993 7.073 0.024 4.291 7.073 0.01821 * rs2400478 1.662 0.056 1.055 1.662 0.35752 rs714588 0.659 0.061 0.150 0.659 0.65815 rs1023555 0.221 0.104 0.261 0.261 0.84692 rs898070 0.020 1.794 0.346 1.794 0.33162 rs963218 0.165 0.190 0.263 0.263 0.84295 rs1419835 1.084 0.775 0.295 1.084 0.51076 rs765023 1.959 0.526 0.483 1.959 0.30142 rs1345267 2.582 0.003 1.383 2.582 0.21106 rs324381 0.175 0.402 0.377 0.402 0.77466 rs184448 9.710 2.026 8.253 9.710 0.00339 ** rs324396 2.312 0.188 1.051 2.312 0.24921 rs324957 7.598 2.134 7.157 7.598 0.01437 * rs324960 2.901 7.928 6.443 7.928 0.01159 * rs10486657 0.054 0.500 0.001 0.500 0.72957 rs324981 3.168 2.431 4.270 4.270 0.08105 . rs1419780 0.123 1.193 0.005 1.193 0.47806 rs325462 1.545 1.645 2.412 2.412 0.23342 rs727162 3.022 0.643 3.074 3.074 0.16080 rs10250709 0.737 0.007 0.360 0.737 0.62798 rs6958905 0.490 0.099 0.447 0.490 0.73268 rs10238983 0.094 0.692 0.328 0.692 0.64821 rs4941643 1.294 0.006 0.465 1.294 0.44652 rs3794381 0.127 0.998 0.489 0.998 0.53565 rs2031532 0.025 0.240 0.127 0.240 0.85704 rs2247119 0.379 0.000 0.229 0.379 0.78427 rs8000149 0.020 0.043 0.043 0.043 0.97280 rs2274276 0.005 0.034 0.023 0.034 0.97788 rs7332573 1.247 1.703 1.825 1.825 0.32966 rs3829366 1.137 0.448 0.069 1.137 0.49124 rs6084432 2.999 0.848 3.279 3.279 0.14197 rs512625 2.180 0.030 1.119 2.180 0.26476 rs3918395 0.903 0.414 0.455 0.903 0.57149 rs2787095 0.178 0.069 0.184 0.184 0.88729 rs2853215 0.686 0.931 1.130 1.130 0.49261 --- Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 We note that even under the max-statistics none of the SNPs tested is significant under the Bonferroni correction (&lt;0.0001) for multiple SNP testing #minimum P-value across SNPs min(ans.max[&quot;Pr(&gt;z)&quot;,]) [1] 0.003392342 Information for specific association models for given SNPs can also be retrieved with WGstats infoTable &lt;- WGstats(ans) Therefore, we can have access to the results for a given SNP by infoTable$rs1422993 SNP: rs1422993 adjusted by: 0 % 1 % OR lower upper p-value AIC Codominant G/G 730 59.0 173 50.9 1.00 0.017768 1642 G/T 425 34.3 145 42.6 1.44 1.12 1.85 T/T 83 6.7 22 6.5 1.12 0.68 1.84 Dominant G/G 730 59.0 173 50.9 1.00 0.007826 1642 G/T-T/T 508 41.0 167 49.1 1.39 1.09 1.77 Recessive G/G-G/T 1155 93.3 318 93.5 1.00 0.877863 1649 T/T 83 6.7 22 6.5 0.96 0.59 1.57 Overdominant G/G-T/T 813 65.7 195 57.4 1.00 0.005026 1641 G/T 425 34.3 145 42.6 1.42 1.11 1.82 log-Additive 0,1,2 1238 78.5 340 21.5 1.22 1.01 1.47 0.040151 1644 recovering our previous results given by association function. NOTE: The R output of specific association analyses can be exported into LaTeX by using getNiceTable function and xtable R package. The following code creates a table for the SNPs rs1422993 and rs184448 library(xtable) out &lt;- getNiceTable(ans[c(&quot;rs1422993&quot;, &quot;rs184448&quot;)]) nlines &lt;- attr(out, &quot;nlines&quot;) hlines &lt;- c(-1, -1, 0, cumsum(nlines+1), nrow(out), nrow(out)) print(xtable(out, caption=&#39;Genetic association using different genetic models from asthma data example of rs1422993 and rs184448 SNPs obtained with SNPassoc.&#39;, label = &#39;tab-2SNPs&#39;), tabular.enviroment=&quot;longtable&quot;, file=&quot;tableSNPs&quot;, floating=FALSE, include.rownames = FALSE, hline.after= hlines, sanitize.text.function=identity) 3.4 Gene-environment and gene-gene interactions Gene-enviroment (GxE) analyses can be performed within SNPassoc using association function. Assume that we are interested in testing whether the risk of rs1422993 for asthma under the dominant model is different among smokers (variable smoke; 0=never, 1=ever). This code fits a model with an interaction term where the environmental variable is required to be a factor factor variable. association(casecontrol ~ dominant(rs1422993)*factor(smoke), data=asthma.s) SNP: dominant(rs1422993 adjusted by: Interaction --------------------- 0 OR lower upper 1 OR lower upper 0 1 2 G/G 273 86 1.00 NA NA 213 44 0.66 0.44 0.98 182 34 0.59 G/T-T/T 210 77 1.16 0.82 1.66 144 51 1.12 0.75 1.68 115 24 0.66 lower upper 0 1 3 lower upper 0 1 4 lower upper G/G 0.38 0.92 40 2 0.16 0.04 0.67 20 7 1.11 0.45 2.72 G/T-T/T 0.40 1.09 19 7 1.17 0.48 2.88 16 7 1.39 0.55 3.49 p interaction: 0.13712 factor(smoke) within dominant(rs1422993 --------------------- G/G 0 1 OR lower upper 0 273 86 1.00 NA NA 1 213 44 0.66 0.44 0.98 2 182 34 0.59 0.38 0.92 3 40 2 0.16 0.04 0.67 4 20 7 1.11 0.45 2.72 G/T-T/T 0 1 OR lower upper 0 210 77 1.00 NA NA 1 144 51 0.97 0.64 1.46 2 115 24 0.57 0.34 0.95 3 19 7 1.00 0.41 2.48 4 16 7 1.19 0.47 3.01 p trend: 0.13712 dominant(rs1422993 within factor(smoke) --------------------- 0 0 1 OR lower upper G/G 273 86 1.00 NA NA G/T-T/T 210 77 1.16 0.82 1.66 1 0 1 OR lower upper G/G 213 44 1.00 NA NA G/T-T/T 144 51 1.71 1.09 2.7 2 0 1 OR lower upper G/G 182 34 1.00 NA NA G/T-T/T 115 24 1.12 0.63 1.98 3 0 1 OR lower upper G/G 40 2 1.00 NA NA G/T-T/T 19 7 7.37 1.4 38.89 4 0 1 OR lower upper G/G 20 7 1.00 NA NA G/T-T/T 16 7 1.25 0.36 4.31 p trend: 0.278 The result is an interaction table showing that the risk of individuals carrying the T allele increases the risk of asthma in never smokers (OR=1.35; CI: 1.02-1.79) while it is not significant in ever smokers (OR=0.95; CI: 0.63-1.42). However, the interaction is not statistically significant (\\(P\\)-interaction=0.8513). The output also shows the stratified ORs that can help in interpreting the results. In a similar way, gene-gene interaction (GxG) of a given SNP epistasis model can also be fitted using the same function. In that case, the genetic model of the interacting SNP must be indicated in the model.inteaction argument. association(casecontrol ~ rs1422993*factor(rs184448), data=asthma.s, model.interaction = &quot;dominant&quot; ) SNP: rs1422993 adjusted by: Interaction --------------------- T/T OR lower upper T/G OR lower upper 0 1 G/G G/G 227 43 1.00 NA NA 359 96 1.41 0.95 2.10 128 30 1.24 G/T-T/T 154 33 1.13 0.69 1.86 265 93 1.85 1.24 2.77 78 38 2.57 lower upper G/G 0.74 2.07 G/T-T/T 1.55 4.27 p interaction: 0.24499 factor(rs184448) within rs1422993 --------------------- G/G 0 1 OR lower upper T/T 227 43 1.00 NA NA T/G 359 96 1.41 0.95 2.10 G/G 128 30 1.24 0.74 2.07 G/T-T/T 0 1 OR lower upper T/T 154 33 1.00 NA NA T/G 265 93 1.64 1.05 2.55 G/G 78 38 2.27 1.32 3.90 p trend: 0.24499 rs1422993 within factor(rs184448) --------------------- T/T 0 1 OR lower upper G/G 227 43 1.00 NA NA G/T-T/T 154 33 1.13 0.69 1.86 T/G 0 1 OR lower upper G/G 359 96 1.00 NA NA G/T-T/T 265 93 1.31 0.95 1.82 G/G 0 1 OR lower upper G/G 128 30 1.00 NA NA G/T-T/T 78 38 2.08 1.19 3.62 p trend: 0.12743 We observe that the interaction between these two SNPs is not statistically significant (P-value=0.24). However, the OR of GG genotype of rs184448 differs across individuals between the GG and GT-TT genotypes of rs1422993 (see ORs for GG in the second table of the output). The user also can perform GxG for a set of SNPs using this code. Let us assume we are interested in assessing interaction between the SNPs that are significant at 10% level ans &lt;- WGassociation(casecontrol, data=asthma.s) mask &lt;- apply(ans, 1, function(x) min(x, na.rm=TRUE)&lt;0.1) sig.snps &lt;- names(mask[mask]) sig.snps [1] &quot;rs1430094&quot; &quot;rs1422993&quot; &quot;rs765023&quot; &quot;rs184448&quot; &quot;rs324396&quot; [6] &quot;rs324957&quot; &quot;rs324960&quot; &quot;rs324981&quot; &quot;rs727162&quot; &quot;rs6084432&quot; idx &lt;- which(colnames(asthma)%in%sig.snps) asthma.s2 &lt;- setupSNP(asthma, colSNPs = idx, sep=&quot;&quot;) ans.int &lt;- interactionPval(casecontrol ~ 1, data=asthma.s2) ans.int rs1430094 rs1422993 rs765023 rs184448 rs324396 rs1430094 0.132526514 0.653457029 0.816154586 0.787386835 0.694311497 rs1422993 0.140433948 0.016719949 0.133131712 0.375246182 0.683959376 rs765023 0.171993821 0.144029395 0.182805988 0.961405419 0.194520134 rs184448 0.100074594 0.019963426 0.034666219 0.007969948 0.036825613 rs324396 0.204742661 0.190583402 0.131945703 0.344952544 0.209589962 rs324957 0.103680541 0.019820456 0.034446832 0.696623215 0.318903026 rs324960 0.107216765 0.024180405 0.174801032 0.291457716 0.584132142 rs324981 0.128489057 0.144077239 0.153521356 0.646139555 0.301782199 rs727162 0.258828613 0.240900610 0.188971595 0.173341993 0.120240909 rs6084432 0.214413938 0.187372912 0.187830183 0.264160389 0.252965105 rs324957 rs324960 rs324981 rs727162 rs6084432 rs1430094 0.644661690 0.096913557 0.774083175 0.043758067 0.946641185 rs1422993 0.257661509 0.175946789 0.095251421 0.577504655 0.027437424 rs765023 0.437535350 0.614095008 0.117705086 0.217580773 0.896707843 rs184448 0.018290318 0.356124918 0.311031078 0.297592380 0.349332875 rs324396 0.232076552 0.747574191 0.064231657 0.361336095 0.388626207 rs324957 0.019578585 0.595796247 0.965290164 0.402781904 0.272919867 rs324960 0.404830873 0.017401694 0.168077057 0.406220478 0.725774374 rs324981 0.657378128 0.533095852 0.117043376 0.463436271 0.862291944 rs727162 0.174960014 0.500811687 0.167364803 0.206131411 0.885294485 rs6084432 0.174006927 0.146808311 0.210647392 0.203957720 0.193711884 we can visualize the results by plot(ans.int) Figure 3.5: Interaction plot. Interaction plot of SNPs significant al 10% significant level (see help of ‘interactionPval’ function to see what is represented in the plot). 3.5 Haplotype analysis Genetic association studies can be extended from single SNP associations to haplotype associations. Several examples including different complex diseases can be found in . While alleles naturally occur in haplotypes, as they belong to chromosomes, the phase, or the knowledge of the chromosome an allele belongs to is lost in the genotyping process. As each genotype is measured with a different probe the phase between the alleles in a chromosome is broken. Consider for instance an individual for which one chromosome has alleles A and T at two different loci and alleles G or C at the second chromosome. The individual’s genotypes for the individual at the two loci are A/G and T/C, which are the same genotypes of another individual that has alleles A and C in one chromosome and G and T in the second chromosome. Clearly, if the pair A-T confers a risk to a disease, subject one is at risk while subject two is not, despite both of them having the same genotypes. The only unequivocal method of resolving phase ambiguity is sequencing the chromosomes of individuals. However, given the correlational structure of SNPs, it is possible to estimate the probability of a particular haplotype in a subject. This can be done in a genetic association study where a number of cases and controls are genotyped. There are numerous methods to infer unobserved haplotypes, two of the most popular are maximum likelihood, implemented via the expectation-maximization (EM) algorithm , and a parsimony method . Recent methods based on Bayesian models have also been proposed . In addition, haplotypes inferences carry uncertainty, which should be considered in association analyses. 3.5.1 Haplotype estimation We now illustrate how to perform haplotype estimation from genotype data using the EM algorithm and how to integrate haplotype uncertainty when evaluating the association between traits and haplotypes. Haplotype inference is performed with haplo.stats, for which genotypes are encoded in a different format. make.geno, from SNPassoc, formats data for haplo.stats. The function haplo.em computes the haplotype frequency in the data for the SNPs of interest. Here we illustrate how to estimate haplotypes built from the SNPs rs714588, rs1023555 and rs898070: library(haplo.stats) snpsH &lt;- c(&quot;rs714588&quot;, &quot;rs1023555&quot;, &quot;rs898070&quot;) genoH &lt;- make.geno(asthma.s, snpsH) em &lt;- haplo.em(genoH, locus.label = snpsH, miss.val = c(0, NA)) em ====================================================================== Haplotypes ====================================================================== rs714588 rs1023555 rs898070 hap.freq 1 1 1 1 0.04090 2 1 1 2 0.02439 3 1 2 1 0.04265 4 1 2 2 0.44047 5 2 1 1 0.08271 6 2 1 2 0.08403 7 2 2 1 0.20794 8 2 2 2 0.07691 ====================================================================== Details ====================================================================== lnlike = -4102.691 lr stat for no LD = 774.5411 , df = 4 , p-val = 0 Coding the common and variant alleles as 1 and 2, we can see there are 8 possible haplotypes across the subjects and are listed with an estimated haplotype frequency. Clearly, the haplotypes are not equally probable, as expected from the high LD between the SNPs. In particular, we observe that haplotypes 4 and 7 are the most probable, accumulating 65% of the haplotype sample. haplo.em estimates for each subject the probability of a given haplotype in each of the subject’s chromosomes. 3.5.2 Haplotype association We then want to assess if any of these haplotypes significantly associates with asthma. The haplo.glm fits a regression model between the phenotype and the haplotypes, incorporating the uncertainty for the probable haplotypes of individuals. The function intervals of SNPassoc provides a nice summary of the results trait &lt;- asthma.s$casecontrol mod &lt;- haplo.glm(trait ~ genoH, family=&quot;binomial&quot;, locus.label=snpsH, allele.lev=attributes(genoH)$unique.alleles, control = haplo.glm.control(haplo.freq.min=0.05)) intervals(mod) freq or 95% C.I. P-val ATG 0.4405 1.00 Reference haplotype GAA 0.0827 1.09 ( 0.77 - 1.56 ) 0.6160 GAG 0.0841 0.99 ( 0.69 - 1.42 ) 0.9642 GTA 0.2080 1.06 ( 0.84 - 1.34 ) 0.6379 GTG 0.0769 1.09 ( 0.76 - 1.58 ) 0.6367 genoH.rare 0.1079 1.15 ( 0.83 - 1.59 ) 0.3968 haplo.glm fits a logistic regression model for the asthma status (trait - NOTE: this must be a 0/1 variable) on the inferred haplotypes (genoH), the names of SNPs and their allele names are passed in the locus.label and allele.lev arguments, while only haplotypes with at least 5% frequency are considered. As a result, we obtain the OR for each haplotype with their significance P-value, with respect to the most common haplotype (ATG with 44% frequency). In particular, from this analysis, we cannot see any haplotype significantly associated with asthma. 3.5.3 Sliding window approach The inference of haplotypes depends on a predefined region or sets of SNPs. For instance, in the last section, we selected three SNPs that were in high LD. However, when no previous knowledge is available about the region or SNPs for which haplotypes should be inferred, we can apply a sliding window for haplotype inference . To illustrate this type of analysis, we now consider a second block of 10 SNPs in our asthma example (from 6th to 15th SNP). Considering large haplotypes, however, increases the number of possible haplotypes in the sample, decreasing the power of finding real associations. In addition, in predefined blocks, it is possible to miss the most efficient length of the susceptible haplotype, incrementing the loss of power. This is overcome using a sliding window. We thus ask which is the haplotype combination from any of 4, 5, 6 or 7 consecutive SNPs that gives the highest association with asthma status. We then reformat SNP genotypes in the region with the make.geno function and perform an association analysis for multiple haplotypes of i SNPs sliding from the 6th to the 15th SNP in the data. We perform an analysis for each window length i varying from 4 to 7 SNPs. snpsH2 &lt;- labels(asthma.s)[6:15] genoH2 &lt;- make.geno(asthma.s, snpsH2) haplo.score &lt;- list() for (i in 4:7) { trait &lt;- asthma.s$casecontrol haplo.score[[i-3]] &lt;- haplo.score.slide(trait, genoH2, trait.type=&quot;binomial&quot;, n.slide=i, simulate=TRUE, sim.control=score.sim.control(min.sim=100, max.sim=200)) } The results can be visualized with the following plot par(mfrow=c(2,2)) for (i in 4:7) { plot(haplo.score[[i-3]]) title(paste(&quot;Sliding Window=&quot;, i, sep=&quot;&quot;)) } Figure 3.6: Sliding window approach. Results obtained of varying haplotype size from 4 up to 7 of 6th to the 15th SNP from asthma data example We observe that the highest -log10(P-value) is obtained for a haplotype of 4 SNP length starting at the 4th SNP of the selected SNPs. After deciding the best combination of SNPs, the haplotype association with asthma can be estimated by snpsH3 &lt;- snpsH2[4:7] genoH3 &lt;- make.geno(asthma.s, snpsH3) mod &lt;- haplo.glm(trait~genoH3, family=&quot;binomial&quot;, locus.label=snpsH3, allele.lev=attributes(genoH3)$unique.alleles, control = haplo.glm.control(haplo.freq.min=0.05)) intervals(mod) freq or 95% C.I. P-val TCCC 0.3521 1.00 Reference haplotype GCCC 0.2963 1.01 ( 0.82 - 1.24 ) 0.9495 TTCA 0.1184 0.89 ( 0.67 - 1.20 ) 0.4433 TTTA 0.1830 1.12 ( 0.87 - 1.43 ) 0.3796 genoH3.rare 0.0502 0.78 ( 0.50 - 1.22 ) 0.2750 Here, we observe that individuals carrying the haplotype GCAC have a 53% increased risk of asthma relative to those having the reference haplotype TCGT (OR=1.53, p=0.0021). The haplotype GTCA is also significantly associated with the disease (p=0.0379). A likelihood ratio test for haplotype status can be extracted from the results of the haplo.glme function: lrt &lt;- mod$lrt pchisq(lrt$lrt, lrt$df, lower=FALSE) [1] 0.5044641 We can also test the association between asthma and the haplotype adjusted for smoking status smoke &lt;- asthma.s$smoke mod.adj.ref &lt;- glm(trait ~ smoke, family=&quot;binomial&quot;) mod.adj &lt;- haplo.glm(trait ~ genoH3 + smoke , family=&quot;binomial&quot;, locus.label=snpsH3, allele.lev=attributes(genoH3)$unique.alleles, control = haplo.glm.control(haplo.freq.min=0.05)) lrt.adj &lt;- mod.adj.ref$deviance - mod.adj$deviance pchisq(lrt.adj, mod.adj$lrt$df, lower=FALSE) [1] 0.6497138 3.6 Genetic score A genetic score, also called a polygenic risk score or genetic risk score, is given by the number of risk alleles that an individual carries (Dudbridge 2013). Genetic scores aim to assess the collective prediction of the phenotype risk associated with multiple SNPs. The SNPs to be included in a genetic score can be selected from different sources. They may be selected from candidate genes, from reported SNPs associated with the trait, or from significant SNPs from a given analysis. We illustrate how to perform a genetic risk score analysis with the asthma study, using the package PredictABEL. We start by performing the single SNP analysis, as previously discussed ans &lt;- WGassociation(casecontrol, asthma.s, model=&quot;log-add&quot;) We choose the SNPs that show an association at 0.1 level to be included in a multivariate model, sel &lt;- labels(asthma.s)[additive(ans)&lt;0.1] asthma.sel &lt;- asthma.s[,sel] head(asthma.sel) rs1422993 rs184448 rs324957 rs324960 rs324981 rs727162 rs6084432 1 G/G T/T G/G C/T A/T G/G G/G 2 G/T G/G A/A C/C A/A G/G G/G 3 G/G T/T G/G C/T T/T G/C G/A 4 G/T T/G G/A C/C A/T G/G G/G 5 G/T T/T G/G C/C A/T G/G G/G 6 G/G T/T G/G C/T A/T G/C G/G We join the SNPs and case/control variable in a single data.frame. Using the additive(), we recode the SNP genotypes as 0, 1 or 2 where the homozygous for the alternative allele is 2. As such, the genetic score is the sum of alternative alleles over selected SNPs asthma.sel &lt;- data.frame(lapply(asthma.sel, additive)) dd.end &lt;- data.frame(casecontrol=asthma.s$casecontrol, asthma.sel) head(dd.end) casecontrol rs1422993 rs184448 rs324957 rs324960 rs324981 rs727162 1 0 0 0 0 1 1 0 2 0 1 2 2 0 0 0 3 0 0 0 0 1 2 1 4 0 1 1 1 0 1 0 5 1 1 0 0 0 1 0 6 0 0 0 0 1 1 1 rs6084432 1 0 2 0 3 1 4 0 5 0 6 0 A multivariate regression model is fitted with all the SNPs to further select those that best predict the asthma status. An automatic variable selection, based on Akaike information criteria (AIC), can be applied to the model using the stepAIC() function from library MASS. Note that the function does not support missing values and requires having complete cases (i.e. no missing values on genotypes). library(MASS) dd.end.complete &lt;- dd.end[complete.cases(dd.end),] mod &lt;- stepAIC(glm(casecontrol ~ ., dd.end.complete, family=&quot;binomial&quot;), method=&quot;forward&quot;, trace=0) The selected SNPs, from the multivariate model, in snps.score are then used to create the genetic score. First, a summary shows the SNPs’ associations of the selected SNPs with the trait summary(mod) Call: glm(formula = casecontrol ~ rs1422993 + rs324957 + rs727162 + rs6084432, family = &quot;binomial&quot;, data = dd.end.complete) Deviance Residuals: Min 1Q Median 3Q Max -0.9775 -0.7290 -0.6655 -0.5596 1.9655 Coefficients: Estimate Std. Error z value Pr(&gt;|z|) (Intercept) -1.77498 0.13635 -13.018 &lt; 2e-16 *** rs1422993 0.20528 0.09849 2.084 0.03714 * rs324957 0.25937 0.09266 2.799 0.00512 ** rs727162 0.18037 0.10447 1.727 0.08424 . rs6084432 0.19982 0.11388 1.755 0.07932 . --- Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 (Dispersion parameter for binomial family taken to be 1) Null deviance: 1587.0 on 1517 degrees of freedom Residual deviance: 1569.2 on 1513 degrees of freedom AIC: 1579.2 Number of Fisher Scoring iterations: 4 This is the code to retrieve the selected SNPs to create the genetic score: snps.score &lt;- names(coef(mod))[-1] snps.score [1] &quot;rs1422993&quot; &quot;rs324957&quot; &quot;rs727162&quot; &quot;rs6084432&quot; The function riskScore() of the PredictABEL package creates the risk score pos &lt;- which(names(dd.end.complete)%in%snps.score) names(dd.end.complete) [1] &quot;casecontrol&quot; &quot;rs1422993&quot; &quot;rs184448&quot; &quot;rs324957&quot; [5] &quot;rs324960&quot; &quot;rs324981&quot; &quot;rs727162&quot; &quot;rs6084432&quot; pos [1] 2 4 7 8 score &lt;- riskScore(mod, data=dd.end.complete, cGenPreds=pos, Type=&quot;unweighted&quot;) table(score) score 0 1 2 3 4 5 6 101 389 491 347 139 44 7 The distribution of the score across individuals can be seen in Figure 3.7 hist(score, col=&quot;gray90&quot;) Figure 3.7: Distribution of the genetic score used to predict case/control status in the asthma example. Once the genetic score is created, we test its association with asthma status using a general linear model mod.lin &lt;- glm(casecontrol~score, dd.end.complete, family=&quot;binomial&quot;) mod.lin Call: glm(formula = casecontrol ~ score, family = &quot;binomial&quot;, data = dd.end.complete) Coefficients: (Intercept) score -1.7612 0.2151 Degrees of Freedom: 1517 Total (i.e. Null); 1516 Residual Null Deviance: 1587 Residual Deviance: 1570 AIC: 1574 exp(coef(mod.lin)[2]) score 1.240039 We observe that the risk of asthma increases 24% per each risk allele. The predictive power of the genetic score can be assessed by computing the area under the ROC curve (AUC). predrisk &lt;- predRisk(mod.lin, dd.end.complete) plotROC(data=dd.end.complete, cOutcome=1, predrisk = predrisk) Figure 3.8: ROC curve of the genetic score used to predict case/control status in the asthma example. AUC [95% CI] for the model 1 : 0.574 [ 0.54 - 0.607 ] Figure 3.8 shows that the predictive power of the genetic score is 57.4% with a 95% confidence interval (54.0 - 60.7). References "],
["genome-wide-association-studies.html", "4 Genome-wide association studies 4.1 Quality control of SNPs 4.2 Quality control of individuals 4.3 Population ancestry 4.4 Genome-wide association analysis", " 4 Genome-wide association studies In this chapter we explain how to perform genome-wide association studies (GWAS), where high-dimensional genomic data is treated. Issues concerning quality control of SNPs and individuals are discussed, as well as association tests and possible sources of confounding such as population stratification. We finish SNP analyses with tools that help to interpret results (e.g. post-omic data analyses). GWAS assess the association between the trait of interest and up to millions of SNPs. GWAS have been used to discover thousands of SNPsassociated with several complex diseases (MacArthur et al. 2016). The basic statistical methods are similar to those previously described, in particular, the massive univariate testing. The main issue with GWAS is data management and computation. Most publicly available data is in PLINK format, where genomic data is stored in a binary BED file, and phenotype and annotation data in text BIM and FAM files. PLINK data can be loaded into R with the Bioconductor’s package snpStats. We illustrate the analysis of a GWAS including 100,000 SNPs that have been simulated using real data from a case-control study. Our phenotype of interest is obesity (0: not obese; 1: obese) that has been created using body mass index information of each individual. We start by loading genotype data that are in PLINK format (obesity.bed, obesity.bim, obesity.fam files). library(snpStats) path &lt;- &quot;data&quot; ob.plink &lt;- read.plink(file.path(path, &quot;obesity&quot;)) The imported object is a list containing the genotypes, the family structure and the SNP annotation. names(ob.plink) [1] &quot;genotypes&quot; &quot;fam&quot; &quot;map&quot; We store genotype, annotation and family data in different variables for downstream analyses ob.geno &lt;- ob.plink$genotypes ob.geno A SnpMatrix with 2312 rows and 100000 columns Row names: 100 ... 998 Col names: MitoC3993T ... rs28600179 annotation &lt;- ob.plink$map head(annotation) chromosome snp.name cM position allele.1 allele.2 MitoC3993T NA MitoC3993T NA 3993 T C MitoG4821A NA MitoG4821A NA 4821 A G MitoG6027A NA MitoG6027A NA 6027 A G MitoT6153C NA MitoT6153C NA 6153 C T MitoC7275T NA MitoC7275T NA 7275 T C MitoT9699C NA MitoT9699C NA 9699 C T family &lt;- ob.plink$fam head(family) pedigree member father mother sex affected 100 FAM_OB 100 NA NA 1 1 1001 FAM_OB 1001 NA NA 1 1 1004 FAM_OB 1004 NA NA 2 2 1005 FAM_OB 1005 NA NA 1 2 1006 FAM_OB 1006 NA NA 2 1 1008 FAM_OB 1008 NA NA 1 1 Notice that geno is an object of class SnpMatrixthat stores the SNPs in binary (raw) format. While some basic phenotype data is usually available in the fam field of the SnpMatrix object, a more complete phenotypic characterization of the sample is usually distributed in additional text files. In our example, the complete phenotype data is in a tab-delimited file ob.pheno &lt;- read.delim(file.path(path, &quot;obesity.txt&quot;)) head(ob.pheno) scanID gender obese age smoke country asthma 1 100 Male 0 48 Never 53 1 2 1001 Male 1 49 Never 54 1 3 1004 Female 0 38 Ex 51 2 4 1005 Male 0 39 Never 53 2 5 1006 Female 0 43 Ex 53 1 6 1008 Male 1 49 Never 55 1 The file contains phenotypic information for a different set of individuals that overlap with those in the ob.geno object. Therefore, before analysis, we need to correctly merge and order the individuals across genomic and phenotype datasets. The row names of ob.geno correspond to the individual identifiers (id) variable of ob.pheno. Consequently, we also rename the rows of ob.pheno with the id variable rownames(ob.pheno) &lt;- ob.pheno$scanID We can check if the row names of the datasets match identical(rownames(ob.pheno), rownames(ob.geno)) [1] TRUE FALSE indicates that either there are different individuals in both objects or that they are in different order. This can be fixed by selecting common individuals. ids &lt;- intersect(rownames(ob.pheno), rownames(ob.geno)) geno &lt;- ob.geno[ids, ] ob &lt;- ob.pheno[ids, ] identical(rownames(ob), rownames(geno)) [1] TRUE family &lt;- family[ids, ] 4.1 Quality control of SNPs We now perform the quality control (QC)of genomic data at the SNP and individual levels, before association testing (Anderson et al. 2010). Different measures can be used to perform QC and remove: SNPs with a high rate of missing; rare SNPS (e.g. having low minor allele frequency (MAF); and SNPs that do not pass the HWE test. Typically, markers with a call rate less than 95% are removed from association analyses, although some large studies chose higher call-rate thresholds (99%). Markers of low MAF (\\(&lt;5\\)%) are also filtered. The significance threshold rejecting a SNP for not being in HWE has varied greatly between studies, from thresholds between 0.001 and \\(5.7 \\times 10^{-7}\\) (Clayton et al. 2005). Including SNPs with extremely low \\(P\\)-values for the HWE test will require individual examination of the SNP genotyping process. A parsimonious threshold of 0.001 may be considered, though robustly genotyped SNPs below this threshold may remain in the study (Anderson et al. 2010), as deviations from HWE may indeed arise from biological processes. The function col.summary() offers different summaries (at SNP level) that can be used in QC info.snps &lt;- col.summary(geno) head(info.snps) Calls Call.rate Certain.calls RAF MAF MitoC3993T 2286 0.9887543 1 0.9851269 0.0148731409 MitoG4821A 2282 0.9870242 1 0.9982472 0.0017528484 MitoG6027A 2307 0.9978374 1 0.9956654 0.0043346337 MitoT6153C 2308 0.9982699 1 0.9893847 0.0106152513 MitoC7275T 2309 0.9987024 1 0.9991338 0.0008661758 MitoT9699C 2302 0.9956747 1 0.9268028 0.0731972198 P.AA P.AB P.BB z.HWE MitoC3993T 0.0148731409 0.0000000000 0.9851269 -47.81213 MitoG4821A 0.0017528484 0.0000000000 0.9982472 -47.77028 MitoG6027A 0.0043346337 0.0000000000 0.9956654 -48.03124 MitoT6153C 0.0103986135 0.0004332756 0.9891681 -47.05069 MitoC7275T 0.0008661758 0.0000000000 0.9991338 -48.05206 MitoT9699C 0.0729800174 0.0004344049 0.9265856 -47.82555 snpStats does not compute \\(P\\)-values of the HWE test but computes its \\(z\\)-scores. A \\(P\\)-value of 0.001 corresponds to a \\(z\\)-score of \\(\\pm 3.3\\) for a two-tail test. Strictly speaking, the HWE test should be applied to controls only (e.g. obese = 0). However, the default computation is for all samples. We thus filter SNPs with a call rate \\(&gt;95\\%\\), MAF of \\(&gt;5\\%\\) and \\(z.HWE&lt;3.3\\) in controls controls &lt;- ob$obese ==0 &amp; !is.na(ob$obese) geno.controls &lt;- geno[controls,] info.controls &lt;- col.summary(geno.controls) use &lt;- info.snps$Call.rate &gt; 0.95 &amp; info.snps$MAF &gt; 0.05 &amp; abs(info.controls$z.HWE &lt; 3.3) mask.snps &lt;- use &amp; !is.na(use) geno.qc.snps &lt;- geno[ , mask.snps] geno.qc.snps A SnpMatrix with 2312 rows and 88723 columns Row names: 100 ... 998 Col names: MitoT9699C ... rs28562204 annotation &lt;- annotation[mask.snps, ] It is common practice to report the number of SNPs that have been removed from the association analyses # number of SNPs removed for bad call rate sum(info.snps$Call.rate &lt; 0.95) [1] 888 # number of SNPs removed for low MAF sum(info.snps$MAF &lt; 0.05, na.rm=TRUE) [1] 10461 #number of SNPs that do not pass HWE test sum(abs(info.controls$z.HWE &gt; 3.3), na.rm=TRUE) [1] 80 # The total number of SNPs do not pass QC sum(!mask.snps) [1] 11277 4.2 Quality control of individuals QC of individuals, or biological samples, comprises four main steps (Anderson et al. 2010): The identification of individuals with discordant reported and genomic sex, the identification of individuals with outlying missing genotype or heterozygosity rate, the identification of duplicated or related individuals, and the identification of individuals of divergent ancestry from the sample. We start by removing individuals with sex discrepancies, a large number of missing genotypes and outlying heterozygosity. The function row.summary() returns the call rate and the proportion of called SNPs which are heterozygous per individual. info.indv &lt;- row.summary(geno.qc.snps) head(info.indv) Call.rate Certain.calls Heterozygosity 100 0.9991547 1 0.3399851 1001 0.9987151 1 0.3456195 1004 0.9953451 1 0.3499943 1005 0.9996168 1 0.3415643 1006 0.9990983 1 0.3482170 1008 0.9995041 1 0.3435763 Gender is usually inferred from the heterozygosity of chromosome X. Males have an expected heterozygosity of 0 and females of 0.30. Chromosome X heterozygosity can be extracted using row.summary() function and then plotted geno.X &lt;- geno.qc.snps[,annotation$chromosome==&quot;23&quot; &amp; !is.na(annotation$chromosome)] info.X &lt;- row.summary(geno.X) mycol &lt;- ifelse(ob$gender==&quot;Male&quot;, &quot;gray40&quot;, &quot;gray80&quot;) plot(info.X$Heterozygosity, col=mycol, pch=16, xlab=&quot;Individuals&quot;, ylab=&quot;Heterozygosity in chromosome X&quot;) legend(&quot;topright&quot;, c(&quot;Males&quot;, &quot;Females&quot;), col=mycol, pch=16) Figure 4.1: Heterozygosity in chromosome X by gender provided in the phenotypic data. Figure 4.1 shows that there are some reported males with non-zero X-heterozygosity and females with zero X-heterozygosity. These samples are located in sex.discrep for later removal sex.discrep &lt;- (ob$gender==&quot;Male&quot; &amp; info.X$Heterozygosity &gt; 0.2) | (ob$gender==&quot;Female&quot; &amp; info.X$Heterozygosity &lt; 0.2) Sex filtering based on X-heterozygosity is not sufficient to identify rare aneuploidies, like XXY in males. Alternatively, plots of the mean allelic intensities of SNPs on the X and Y chromosomes can identify mis-annotated sex as well as sex chromosome aneuploidies. Now, we identify individuals with outlying heterozygosity from the overall genomic heterozygosity rate that is computed by the function row.summary(). Heterozygosity, can also be computed from the statistic \\(F = 1 - \\frac{f(Aa)}{E(f(Aa))}\\), where \\(f(Aa)\\) is the observed proportion of heterozygous genotypes (Aa) of a given individual and \\(E(f(Aa))\\) is the expected proportion of heterozygous genotypes. A subject’s \\(E(f(Aa))\\) can be computed from the MAF across all the subjects’ non-missing SNPs MAF &lt;- col.summary(geno.qc.snps)$MAF callmatrix &lt;- !is.na(geno.qc.snps) hetExp &lt;- callmatrix %*% (2*MAF*(1-MAF)) hetObs &lt;- with(info.indv, Heterozygosity*(ncol(geno.qc.snps))*Call.rate) info.indv$hetF &lt;- 1-(hetObs/hetExp) head(info.indv) Call.rate Certain.calls Heterozygosity hetF 100 0.9991547 1 0.3399851 0.031007624 1001 0.9987151 1 0.3456195 0.014898707 1004 0.9953451 1 0.3499943 0.002145765 1005 0.9996168 1 0.3415643 0.026466552 1006 0.9990983 1 0.3482170 0.007425401 1008 0.9995041 1 0.3435763 0.020744532 In Figure 4.2, we compare \\(F\\) statistic and the Heterozygosity obtained from row.summary() Figure 4.2: Heterozygosity computed using F statistic (left panel) and using row.summary function (right panel). The horizontal dashed line shows a suggestive value to detect individuals with outlier heterozygosity values. Individuals whose \\(F\\) statistic is outside the band \\(\\pm 0.1\\) are considered sample outliers (left panel Figure 4.2 and correspond to those having a heterozygosity rate lower than 0.32. GWASs are studies that are typically based on population samples. Therefore, close familial relatedness between individuals is not representative of the sample. We, therefore, remove individuals whose relatedness is higher than expected. The package SNPRelate is used to perform identity-by-descent (IBD) analysis, computing kinship within the sample. The package requires a data in a GDS format that is obtained with the function snpgdsBED2GDS. In addition, IBD analysis requires SNPs that are not in LD (uncorrelated). The function snpgdsLDpruning iteratively removes adjacent SNPs that exceed an LD threshold in a sliding window library(SNPRelate) # Transform PLINK data into GDS format snpgdsBED2GDS(&quot;data/obesity.bed&quot;, &quot;data/obesity.fam&quot;, &quot;data/obesity.bim&quot;, out=&quot;obGDS&quot;) Start file conversion from PLINK BED to SNP GDS ... BED file: &quot;data/obesity.bed&quot; SNP-major mode (Sample X SNP), 55.1M FAM file: &quot;data/obesity.fam&quot; BIM file: &quot;data/obesity.bim&quot; Wed Nov 11 09:32:28 2020 (store sample id, snp id, position, and chromosome) start writing: 2312 samples, 100000 SNPs ... [..................................................] 0%, ETC: --- [==================================================] 100%, completed, 1s Wed Nov 11 09:32:29 2020 Done. Optimize the access efficiency ... Clean up the fragments of GDS file: open the file &#39;obGDS&#39; (55.7M) # of fragments: 39 save to &#39;obGDS.tmp&#39; rename &#39;obGDS.tmp&#39; (55.7M, reduced: 252B) # of fragments: 18 genofile &lt;- snpgdsOpen(&quot;obGDS&quot;) # Prune SNPs for IBD analysis set.seed(12345) snps.qc &lt;- colnames(geno.qc.snps) snp.prune &lt;- snpgdsLDpruning(genofile, ld.threshold = 0.2, snp.id = snps.qc) SNP pruning based on LD: Excluding 13,410 SNPs (non-autosomes or non-selection) Excluding 0 SNP (monomorphic: TRUE, MAF: NaN, missing rate: NaN) # of samples: 2,312 # of SNPs: 86,590 using 1 thread sliding window: 500,000 basepairs, Inf SNPs |LD| threshold: 0.2 method: composite Chromosome 1: 31.58%, 2,438/7,721 Chromosome 2: 29.98%, 2,413/8,050 Chromosome 3: 30.83%, 2,058/6,676 Chromosome 4: 30.94%, 1,834/5,927 Chromosome 5: 31.05%, 1,886/6,074 Chromosome 6: 28.18%, 1,902/6,750 Chromosome 7: 31.27%, 1,675/5,356 Chromosome 8: 28.86%, 1,608/5,572 Chromosome 9: 31.62%, 1,492/4,718 Chromosome 10: 30.73%, 1,595/5,191 Chromosome 11: 30.93%, 1,476/4,772 Chromosome 12: 31.64%, 1,536/4,855 Chromosome 13: 31.36%, 1,142/3,642 Chromosome 14: 32.72%, 1,063/3,249 Chromosome 15: 31.76%, 972/3,060 Chromosome 16: 35.62%, 1,059/2,973 Chromosome 17: 36.24%, 986/2,721 Chromosome 18: 34.11%, 1,005/2,946 Chromosome 19: 40.80%, 694/1,701 Chromosome 20: 35.66%, 859/2,409 Chromosome 21: 34.83%, 488/1,401 Chromosome 22: 34.61%, 552/1,595 30,733 markers are selected in total. snps.ibd &lt;- unlist(snp.prune, use.names=FALSE) Note that this process is performed with SNPs that passed previous QC checks. IBD coefficients are then computed using the method of moments, implemented in the function snpgdsIBDMoM(). The result of the analysis is a table indicating kinship among pairs of individuals ibd &lt;- snpgdsIBDMoM(genofile, kinship=TRUE, snp.id = snps.ibd, num.thread = 1) IBD analysis (PLINK method of moment) on genotypes: Excluding 69,267 SNPs (non-autosomes or non-selection) Excluding 0 SNP (monomorphic: TRUE, MAF: NaN, missing rate: NaN) # of samples: 2,312 # of SNPs: 30,733 using 1 thread PLINK IBD: the sum of all selected genotypes (0,1,2) = 32774873 Wed Nov 11 09:32:32 2020 (internal increment: 13952) [..................................................] 0%, ETC: --- [==================================================] 100%, completed, 9s Wed Nov 11 09:32:41 2020 Done. ibd.kin &lt;- snpgdsIBDSelection(ibd) head(ibd.kin) ID1 ID2 k0 k1 kinship 1 100 1001 1 0 0 2 100 1004 1 0 0 3 100 1005 1 0 0 4 100 1006 1 0 0 5 100 1008 1 0 0 6 100 1013 1 0 0 A pair of individuals with higher than expected relatedness are considered with kinship score \\(&gt; 0.1\\) ibd.kin.thres &lt;- subset(ibd.kin, kinship &gt; 0.1) head(ibd.kin.thres) ID1 ID2 k0 k1 kinship 46484 1049 188 0.2759234 0.5337773 0.2285940 232848 1202 1330 0.0000000 0.0000000 0.5000000 281069 1237 872 0.2874340 0.4451656 0.2449916 640474 155 1682 0.2377813 0.4570711 0.2668416 806337 170 2015 0.2564809 0.5414546 0.2363959 1158509 2055 825 0.0000000 0.0000000 0.5000000 The ids of the individuals with unusual kinship are located with related() function from the SNPassoc package ids.rel &lt;- SNPassoc::related(ibd.kin.thres) ids.rel [1] &quot;4364&quot; &quot;3380&quot; &quot;2999&quot; &quot;2697&quot; &quot;2611&quot; &quot;2088&quot; &quot;1202&quot; &quot;872&quot; &quot;825&quot; [10] &quot;684&quot; &quot;188&quot; &quot;170&quot; &quot;155&quot; &quot;2071&quot; Summing up, individuals with more than 5% missing genotypes (Consortium and others 2007, @silverberg2009ulcerative), with sex discrepancies, \\(F\\) absolute value \\(&gt;1\\) and kinship coefficient \\(&gt;0.1\\) are removed from the genotype and phenotype data use &lt;- info.indv$Call.rate &gt; 0.95 &amp; abs(info.indv$hetF) &lt; 0.1 &amp; !sex.discrep &amp; !rownames(info.indv)%in%ids.rel mask.indiv &lt;- use &amp; !is.na(use) geno.qc &lt;- geno.qc.snps[mask.indiv, ] ob.qc &lt;- ob.pheno[mask.indiv, ] identical(rownames(ob.qc), rownames(geno.qc)) [1] TRUE These QC measures are usually reported # number of individuals removed to bad call rate sum(info.indv$Call.rate &lt; 0.95) [1] 34 # number of individuals removed for heterozygosity problems sum(abs(info.indv$hetF) &gt; 0.1) [1] 15 # number of individuals removed for sex discrepancies sum(sex.discrep) [1] 8 # number of individuals removed to be related with others length(ids.rel) [1] 14 # The total number of individuals that do not pass QC sum(!mask.indiv) [1] 70 4.3 Population ancestry As GWAS are based on general population samples, individual genetic differences between individuals need to be also representative of the population at large. The main source of genetic differences between individuals is ancestry. Therefore, it is important to check that there are not individuals with unexpected genetic differences in the sample. Ancestral differences can be inferred with principal component analysis (PCA) on the genomic data. Individuals with outlying ancestry can be removed from the study while smaller differences in ancestry can be adjusted in the association models, including the first principal components as covariates. PCA on genomic data can be computed using the SNPRelate package with the snpgdsPCA() function. Efficiency can be improved by removing SNPs that are in LD before PCA, see snps.ibd object in the previous IBD analysis. In addition the functio snpgdsPCA() allows parallelization with the argument num.thread that determines the number of computing cores to be used pca &lt;- snpgdsPCA(genofile, sample.id = rownames(geno.qc), snp.id = snps.ibd, num.thread=1) Principal Component Analysis (PCA) on genotypes: Excluding 69,267 SNPs (non-autosomes or non-selection) Excluding 0 SNP (monomorphic: TRUE, MAF: NaN, missing rate: NaN) # of samples: 2,242 # of SNPs: 30,733 using 1 thread # of principal components: 32 PCA: the sum of all selected genotypes (0,1,2) = 31788248 CPU capabilities: Double-Precision SSE2 Wed Nov 11 09:33:16 2020 (internal increment: 448) [..................................................] 0%, ETC: --- [==================================================] 100%, completed, 31s Wed Nov 11 09:33:47 2020 Begin (eigenvalues and eigenvectors) Wed Nov 11 09:33:52 2020 Done. A PCA plot for the first two components can be obtained with with(pca, plot(eigenvect[,1], eigenvect[,2], xlab=&quot;1st Principal Component&quot;, ylab=&quot;2nd Principal Component&quot;, main = &quot;Ancestry Plot&quot;, pch=21, bg=&quot;gray90&quot;, cex=0.8)) (#fig:pca_plot)1st and 2nd principal components of obesity GWAS data example. Inspection of Figure @ref(fig:pca_plot) can be used to identify individuals with unusual ancestry and remove them. Individuals with outlying values in the principal components will be considered for QC. In our example, we can see outlying individuals on the right side of the plot with 1st PC \\(&gt; 0.05\\). Smaller differences in ancestry are an important source of bias in association tests, as explained later. Therefore, we keep the first five principal components and add it to the phenotypic information that will be used in the association analyses. ob.qc &lt;- data.frame(ob.qc, pca$eigenvect[, 1:5]) After performing QC, the GDS file can be closed closefn.gds(genofile) 4.4 Genome-wide association analysis Genome-wide association analysis involves regressing each SNP separately on our trait of interest. The analyses should be adjusted for clinical, environmental, and/or demographic factors as well as ancestral differences between the subjects. The analysis can be performed with a range of functions in snpStats package. We first examine the unadjusted whole genome association of our obesity study res &lt;- single.snp.tests(obese, data=ob.qc, snp.data=geno.qc) res[1:5,] N Chi.squared.1.df Chi.squared.2.df P.1df MitoT9699C 2134 3.0263311 NA 0.08192307 MitoA11252G 2090 0.3561812 NA 0.55063478 MitoA12309G 2136 0.1776464 NA 0.67340371 MitoG16130A 2069 2.4766387 3.9480296 0.11554896 rs28705211 2125 0.7277258 0.7546827 0.39362135 P.2df MitoT9699C NA MitoA11252G NA MitoA12309G NA MitoG16130A 0.1388981 rs28705211 0.6856820 This analysis is only available for the additive (\\(\\chi^2\\)(1.df)) and the codominant models (\\(\\chi^2\\)(2.df)). It requires the name variable phenotype (obese) in the data argument. Genomic data are given in the snp.data argument. It is important that the individuals in the rows of both datasets match. SNPs in the mitochondrial genome and gonosomes return NA for the \\(\\chi^2\\) estimates. These variants should be analyzed separately. A common interest is to analyze autosomes only, and therefore these SNPs can be removed in the QC process. A quantitative trait can also be analyzed setting the argument family equal to “Gaussian” res.quant &lt;- snp.rhs.tests(age ~ 1, data=ob.qc, snp.data=geno.qc, family=&quot;Gaussian&quot;) head(res.quant) Chi.squared Df p.value MitoT9699C 0.003422591 1 0.953348 Population stratificationinflates the estimates of the \\(\\chi^2\\) tests of association between the phenotype and the SNPs, and as a consequence the false positive rate increases. Figure @ref{fig:stratificationExample} illustrates why population stratification may lead to false associations. In the hypothetical study in the figure, we compare 20 cases and 20 controls where individuals carrying a susceptibility allele are denoted by a dot. The overall frequency of the susceptibility allele is much larger in cases (0.55 = 11/20) than in controls (0.35 = 7/20), the odds of being a case in allele carriers is $$2.3 times higher than the odds of being a case in non carriers (OR= 2.27 = (0.55/0.45) / (0.35/0.65)). However, the significant increase in susceptibility between the allele is misleading, as the OR in population A (light color) is 0.89 and in population B (dark color) is 1.08. The susceptibility allele strongly discriminates population A from B, and given the differences of the trait frequency between populations, it is likely that the association of the allele with the trait is through its links with population differences and not with the trait itself. In genome-wide analyses, the inflation of the associations due to undetected latent variables is assessed by quantile-quantile (Q-Q) plots where observed \\(\\chi^2\\) values are plotted against the expected ones chi2 &lt;- chi.squared(res, df=1) qq.chisq(chi2) Figure 4.3: QQ-plot corresponding to obesity GWAS data example. N omitted lambda 88723.000000 0.000000 1.003853 Figure @ref{fig:qqPlot} shows, in particular, that the \\(\\chi^2\\) estimates are not inflated (\\(\\lambda\\) is also close to 1), as all quantile values fall in the confidence bands, meaning that most SNPs are not associated with obesity. In addition, the Figure does not show any top SNP outside the confidence bands. A Q-Q plot with top SNPs outside the confidence bands indicates that those SNPs are truly associated with the disease and, hence, do not follow the null hypothesis. Therefore, the Q-Q plot of our examples reveals no significant SNP associations. Q-Q plots are used to inspect population stratification. In particular, when population stratification is present, most SNP Q-Q values will be found outside the confidence bands, suggesting that the overall genetic structure of the sample can discriminate differences between subject traits. The \\(\\lambda\\) value is a measure of the degree of inflation. The main source of population stratification that is derived from genomic data is ancestry. Therefore, in the cases of inflated Q-Q plots, it is ancestry differences and not individual SNP differences that explain the differences in the phenotype. Population stratification may be corrected by genomic control, mixed models or EIGENSTRAT method Price et al. (2010). However, the most common approach is to use the inferred ancestry from genomic data as covariates in the association analyses Price et al. (2006). Genome-wide association analysis typically adjusts for population stratification using the PCs on genomic data to infer ancestral differences in the sample. Covariates are easily incorporated in the model of snp.rhs.tests() function. res.adj &lt;- snp.rhs.tests(obese ~ X1 + X2 + X3 + X4 + X5, data=ob.qc, snp.data=geno.qc) head(res.adj) Chi.squared Df p.value MitoT9699C 2.660902 1 0.1028424 This function only computes the additive model, adjusting for the first five genomic PCs. The resulting \\(-\\log_{10}(P)\\)-values of association for each SNP are then extracted pval.log10 &lt;- -log10(p.value(res.adj)) These transformed \\(P\\)-values are used to create a Manhattan plot to visualize which SNPs are significantly associated with obesity. We use our function manhattanPlot(), although package qqman can also be used. The function manhattanPlot() can be downloaded as follows: source(&quot;https://raw.githubusercontent.com/isglobal-brge/book_omic_association/master/R/manhattanPlot.R&quot;) library(tidyverse) library(ggplot2) library(ggrepel) # Create the required data frame pvals &lt;- data.frame(SNP=annotation$snp.name, CHR=annotation$chromosome, BP=annotation$position, P=p.value(res.adj)) # missing data is not allowed pvals &lt;- subset(pvals, !is.na(CHR) &amp; !is.na(P)) manhattanPlot(pvals, color=c(&quot;gray90&quot;, &quot;gray40&quot;)) Figure 4.4: Manhattan plot of obesity GWAS data example. Significance at Bonferroni level is set at \\(10^{-7}=0.05/10^5\\), as we are testing 100,000 SNPs. The level corresponds to \\(-\\log_{10}(P)=6.30\\). Therefore, we confirm, as expected form the Q-Q plot, that no SNP in our study is significantly associated with obesity, as observed in Figure @ref{fig:manhattan}. It should be noticed that the standard Bonferroni significant level in GWASs is considered as \\(5 \\times 10^{-8}\\) since SNParray data use to contain 500K-1M SNPs (Pe’er et al. 2008). With our obesity example, we illustrate the common situation of finding no significant associations in small studies (thousands of subjects) with small genomic data (100,000 SNPs). This situation motivates multi-center studies with larger samples sizes, where small effects can be inferred with sufficient power and consistency. The snpStats package performs association analyses using either codominant or additive models and only provides their p-values. Let us imagine we are interested in using SNPassoc to create the tables with the different genetic models for the most significant SNPs. This can be performed as following. We first select the SNPs that pass a p-value threshold. For instance, \\(10^{-5}\\) (in real situations it should be the GWAS level \\(5 \\times 10^{-8}\\)) topPvals &lt;- subset(pvals, P&lt;10e-5) topSNPs &lt;- as.character(topPvals$SNP) We then export the data into a text file that can be imported into R as a data.frame that can be analyzed using SNPassoc # subset top SNPs geno.topSNPs &lt;- geno.qc[, topSNPs] geno.topSNPs A SnpMatrix with 2242 rows and 5 columns Row names: 100 ... 998 Col names: rs10193241 ... rs1935960 # export top SNPs write.SnpMatrix(geno.topSNPs, file=&quot;topSNPs.txt&quot;) [1] 2242 5 # import top SNPs ob.top &lt;- read.delim(&quot;topSNPs.txt&quot;, sep=&quot;&quot;) # add phenotypic information(ids are in the same order) ob.top &lt;- cbind(ob.top, ob.qc) # prepare data for SNPassoc (SNPs are coded as 0,1,2) ii &lt;- grep(&quot;^rs&quot;, names(ob.top)) ob.top.s &lt;- setupSNP(ob.top, colSNPs = ii, name.genotypes=c(0,1,2)) # run association (all) WGassociation(obese, ob.top.s) comments codominant dominant recessive overdominant log-additive rs10193241 - 0.00026 0.19355 0.00005 0.00044 0.00013 rs7349742 - 0.00009 0.01839 0.00004 0.00182 0.00002 rs12201995 - 0.00006 0.00185 0.00011 0.01271 0.00001 rs6931936 - 0.00001 0.00078 0.00002 0.00368 0.00000 rs1935960 - 0.00006 0.74717 0.00001 0.00001 0.00009 # run association (one) association(obese ~ rs10193241, ob.top.s) SNP: rs10193241 adjusted by: 0 % 1 % OR lower upper p-value AIC Codominant A/A 85 4.9 26 6.5 1.00 2.648e-04 2040 A/B 617 35.5 179 45.1 0.95 0.59 1.52 B/B 1034 59.6 192 48.4 0.61 0.38 0.97 Dominant A/A 85 4.9 26 6.5 1.00 1.935e-01 2052 A/B-B/B 1651 95.1 371 93.5 0.73 0.47 1.16 Recessive A/A-A/B 702 40.4 205 51.6 1.00 5.063e-05 2038 B/B 1034 59.6 192 48.4 0.64 0.51 0.79 Overdominant A/A-B/B 1119 64.5 218 54.9 1.00 4.365e-04 2042 A/B 617 35.5 179 45.1 1.49 1.19 1.86 log-Additive 0,1,2 1736 81.4 397 18.6 0.71 0.59 0.84 1.313e-04 2039 References "],
["microarray-data-analysis.html", "5 Microarray data analysis", " 5 Microarray data analysis To be supplied "],
["rnaseq-data-analysis.html", "6 RNAseq data analysis 6.1 Introduction 6.2 Within sample normalization of read counts 6.3 Exploratory analysis of the read counts table 6.4 Differential expression analysis 6.5 Accounting for additional sources of variation", " 6 RNAseq data analysis In this chapter we will assume that the data analyst has obtained a read count table from raw fastq reads obtained from an Illumina sequencing run. This can also be performed using Bioconductor R packages, but sometimes you can ask the core facility for this data since it can be very computational expensive. Here we demonstrate how to process the count table, make a case-control differential expression analysis, and do some downstream functional enrichment analysis that can also be applied to the results obtained from microarrays experiments. 6.1 Introduction The transcription profile of a particular gene follows from counting the number of times the transcripts of the genes were mapped by sequenced reads. The summarized RNA-seq data is known as count data. Figure 6.1 describes the main steps that are taken to obtain the count table that measures the transcription of active genes in biological samples. Figure 6.1: RNA-seq scheme to get count data. The sequenced reads can be counted in a number of different ways: By alignment to the genome and summarized at either gene or transcript (isoform) level. By alignment to the transcriptome and summarized at either gene or transcript (isoform) level. By assembling directly into transcripts and summarized at either gene or transcript (isoform) level. Table 6.2 shows a hypothetical RNA-seq data of \\(G\\) genes obtained for 6 samples, belonging to two different conditions. The main goal is to discover the genes that are differentially expressed between individuals from condition A and B. Figure 6.2: Table of counts for an hypotethical data example. In RNA-seq analysis, we deal with the number of reads (counts) that map to the biological feature of interest (gene, transcript, exon, etc.). The count number depends linearly with the abundance of the target’s transcription because the sequencing of RNA is a direct measure of transcription. This is considered as one of the advantages over microarrays that indirectly measure transcription by hybridization. Figure 6.3 illustrates the type of data from microarray and RNA-seq experiments. While microarray data is continuous, RNA-seq is discrete and, therefore, the modeling of each type of data is different. Figure 6.3: Gene expression distribution obtained from RNA-seq and microarray data from a hypothetical gene. There are two important factors that influence the number of gene counts and which need to be taken into account, see figure 6.4. The first factor is the sequencing depth or library size, that is, the total number of reads mapped to the genome; the second factor is the gene length, i.e. the number of bases covering a gene. It is expected that larger genes, for a given level of transcription, will have more gene counts. Figure 6.4: Key concepts involved in an RNA-seq experiment. 6.2 Within sample normalization of read counts The most common application after a gene’s expression is quantified (as the number of reads aligned to the gene), is to compare the gene’s expression in different conditions, for instance, in a case-control setting (e.g. disease versus normal) or in a time-series (e.g. along different developmental stages). Making such comparisons helps identify the genes that might be responsible for a disease or an impaired developmental trajectory. However, there are multiple caveats that needs to be addressed before making a comparison between the read counts of a gene in different conditions (Maza, et al. 2013). Library size (i.e. sequencing depth) varies between samples coming from different lanes of the flow cell of the sequencing machine. Longer genes will have a higher number of reads. Library composition (i.e. relative size of the studied transcriptome) can be different in two different biological conditions. GC content biases across different samples may lead to a biased sampling of genes. The most basic normalization approaches address the sequencing depth bias. Such procedures normalize the read counts per gene by dividing each gene’s read count by a certain value and multiplying it by \\(10^6\\). These normalized values are usually referred to as CPM (counts per million reads): Total Counts Normalization (divide counts by the sum of all counts) Upper Quartile Normalization (divide counts by the upper quartile value of the counts) Median Normalization (divide counts by the median of all counts) Popular metrics that improve upon CPM are RPKM/FPKM (reads/fragments per kilobase of million reads) and TPM (transcripts per million). RPKM is obtained by dividing the CPM value by another factor, which is the length of the gene per kilobase. FPKM is the same as RPKM, but is used for paired-end reads. Thus, RPKM/FPKM methods account for, firstly, the library size, and secondly, the gene lengths. TPM also controls for both the library size and the gene lengths, however, with the TPM method, the read counts are first normalized by the gene length (per kilobase), and then gene-length normalized values are divided by the sum of the gene-length normalized values and multiplied by \\(10^6\\). Thus, the sum of normalized values for TPM will always be equal to \\(10^6\\) for each library, while the sum of RPKM/FPKM values do not sum to \\(10^6\\). Therefore, it is easier to interpret TPM values than RPKM/FPKM values. Other methods that consider GC content are: cqn (Hansen and Irizarry, 2012), EDAseq (Risso, et al. 2011). We demonstrate different methods to normalize the count data from lymphoblastoid cell lines from 69 unrelated Nigerian individuals, described in Pickrell, et al. 2010. This data are available through the Bioconductor’s tweeDEseqCountData package. library(tweeDEseqCountData) data(pickrell) pickrell.eset ExpressionSet (storageMode: lockedEnvironment) assayData: 52580 features, 69 samples element names: exprs protocolData: none phenoData sampleNames: NA18486 NA18498 ... NA19257 (69 total) varLabels: num.tech.reps population study gender varMetadata: labelDescription featureData featureNames: ENSG00000000003 ENSG00000000005 ... LRG_99 (52580 total) fvarLabels: gene fvarMetadata: labelDescription experimentData: use &#39;experimentData(object)&#39; Annotation: The object pickrell.est is an ExpressionSet containing RNA-seq count data obtained from the ReCount repository available at . Details on the pre-processing steps to obtain this table of counts from the raw reads are provided on the website and in Frazee, et al. 2011. Our aim is to use this data to compare different normalization methods. The most simple normalization is to standardize the counts dividing them by the total number of reads in the sample (size of the libraries) and multiplying by \\(10^6\\) (CPM): counts &lt;- exprs(pickrell.eset) lib.size &lt;- colSums(counts) NormByCPM &lt;- sweep(counts, 2, FUN=&quot;/&quot;, lib.size) * 10^6 Check that the sum of each column after CPM normalization equals to \\(10^6\\) colSums(NormByCPM) NA18486 NA18498 NA18499 NA18501 NA18502 NA18504 NA18505 NA18507 1e+06 1e+06 1e+06 1e+06 1e+06 1e+06 1e+06 1e+06 NA18508 NA18510 NA18511 NA18516 NA18517 NA18519 NA18520 NA18522 1e+06 1e+06 1e+06 1e+06 1e+06 1e+06 1e+06 1e+06 NA18523 NA18852 NA18853 NA18855 NA18856 NA18858 NA18861 NA18862 1e+06 1e+06 1e+06 1e+06 1e+06 1e+06 1e+06 1e+06 NA18870 NA18871 NA18909 NA18912 NA18913 NA18916 NA19093 NA19098 1e+06 1e+06 1e+06 1e+06 1e+06 1e+06 1e+06 1e+06 NA19099 NA19101 NA19102 NA19108 NA19114 NA19116 NA19119 NA19127 1e+06 1e+06 1e+06 1e+06 1e+06 1e+06 1e+06 1e+06 NA19128 NA19130 NA19131 NA19137 NA19138 NA19140 NA19143 NA19144 1e+06 1e+06 1e+06 1e+06 1e+06 1e+06 1e+06 1e+06 NA19147 NA19152 NA19153 NA19159 NA19160 NA19171 NA19172 NA19190 1e+06 1e+06 1e+06 1e+06 1e+06 1e+06 1e+06 1e+06 NA19192 NA19193 NA19200 NA19201 NA19203 NA19204 NA19209 NA19210 1e+06 1e+06 1e+06 1e+06 1e+06 1e+06 1e+06 1e+06 NA19222 NA19225 NA19238 NA19239 NA19257 1e+06 1e+06 1e+06 1e+06 1e+06 For an RPKM (reads per kilobase of transcript and million mapped reads) normalization, we first need to know the length of query regions (e.g. length of genes). This information is also available from the tweeDEseqCountData package, but can also be obtained from biomaRt. data(annotEnsembl63) head(annotEnsembl63) Symbol Chr Start End EntrezID ENSG00000252775 U7 5 133913821 133913880 &lt;NA&gt; ENSG00000207459 U6 5 133970529 133970635 &lt;NA&gt; ENSG00000252899 U7 5 133997420 133997479 &lt;NA&gt; ENSG00000201298 U6 5 134036862 134036968 &lt;NA&gt; ENSG00000222266 U6 5 134051173 134051272 &lt;NA&gt; ENSG00000222924 U6 5 137405044 137405147 &lt;NA&gt; Description ENSG00000252775 U7 small nuclear RNA [Source:RFAM;Acc:RF00066] ENSG00000207459 U6 spliceosomal RNA [Source:RFAM;Acc:RF00026] ENSG00000252899 U7 small nuclear RNA [Source:RFAM;Acc:RF00066] ENSG00000201298 U6 spliceosomal RNA [Source:RFAM;Acc:RF00026] ENSG00000222266 U6 spliceosomal RNA [Source:RFAM;Acc:RF00026] ENSG00000222924 U6 spliceosomal RNA [Source:RFAM;Acc:RF00026] Length GCcontent ENSG00000252775 NA NA ENSG00000207459 NA NA ENSG00000252899 NA NA ENSG00000201298 NA NA ENSG00000222266 NA NA ENSG00000222924 NA NA genes.ok &lt;- intersect(as.character(rownames(counts)), as.character(rownames(annotEnsembl63))) geneAnnot &lt;- annotEnsembl63[genes.ok,] counts.ok &lt;- counts[genes.ok,] identical(rownames(geneAnnot), rownames(counts.ok)) [1] TRUE We obtain annotation data in the object annotEnsembl63 and map it to counts, we then check that both data.frame are in the same order. The RPKM normalization is computed by geneLengths &lt;- geneAnnot$Length NormByRPKM &lt;- t(t(counts.ok / geneLengths *10^3) /colSums(counts.ok)*10^6) Check that the sum of each column after RPKM normalization is not equal to \\(10^6\\) colSums(NormByRPKM, na.rm=TRUE) NA18486 NA18498 NA18499 NA18501 NA18502 NA18504 NA18505 446915.7 468875.1 451749.9 424849.8 465086.6 462163.4 461488.9 NA18507 NA18508 NA18510 NA18511 NA18516 NA18517 NA18519 474510.7 461575.7 463082.1 469532.5 494144.4 453952.3 465812.3 NA18520 NA18522 NA18523 NA18852 NA18853 NA18855 NA18856 475356.5 450742.2 465948.1 449445.6 541396.1 458492.5 446573.0 NA18858 NA18861 NA18862 NA18870 NA18871 NA18909 NA18912 461737.2 419591.0 481777.5 464991.6 448378.9 487215.0 529199.2 NA18913 NA18916 NA19093 NA19098 NA19099 NA19101 NA19102 471316.9 447690.0 436454.4 436349.0 428527.4 450986.4 539169.3 NA19108 NA19114 NA19116 NA19119 NA19127 NA19128 NA19130 464412.9 552272.0 452169.8 488080.0 533040.2 565341.8 460997.0 NA19131 NA19137 NA19138 NA19140 NA19143 NA19144 NA19147 459320.6 451752.3 425970.4 503160.3 462846.1 440995.7 512702.4 NA19152 NA19153 NA19159 NA19160 NA19171 NA19172 NA19190 462656.1 443485.7 435608.1 483709.9 428850.3 459705.1 491931.6 NA19192 NA19193 NA19200 NA19201 NA19203 NA19204 NA19209 465900.2 567158.2 439382.1 465267.3 512908.7 424076.6 468026.6 NA19210 NA19222 NA19225 NA19238 NA19239 NA19257 491900.9 440928.6 510870.3 455355.5 439798.3 498785.3 #find gene length normalized values rpk &lt;- apply(counts.ok, 2, function(x) x/(geneLengths/10^3)) #normalize by the sample size using rpk values NormByTPM &lt;- apply(rpk, 2, function(x) x / sum(as.numeric(x), na.rm=TRUE) * 10^6) Check that the sum of each column after RPM normalization equals to \\(10^6\\) colSums(NormByTPM, na.rm=TRUE) NA18486 NA18498 NA18499 NA18501 NA18502 NA18504 NA18505 NA18507 1e+06 1e+06 1e+06 1e+06 1e+06 1e+06 1e+06 1e+06 NA18508 NA18510 NA18511 NA18516 NA18517 NA18519 NA18520 NA18522 1e+06 1e+06 1e+06 1e+06 1e+06 1e+06 1e+06 1e+06 NA18523 NA18852 NA18853 NA18855 NA18856 NA18858 NA18861 NA18862 1e+06 1e+06 1e+06 1e+06 1e+06 1e+06 1e+06 1e+06 NA18870 NA18871 NA18909 NA18912 NA18913 NA18916 NA19093 NA19098 1e+06 1e+06 1e+06 1e+06 1e+06 1e+06 1e+06 1e+06 NA19099 NA19101 NA19102 NA19108 NA19114 NA19116 NA19119 NA19127 1e+06 1e+06 1e+06 1e+06 1e+06 1e+06 1e+06 1e+06 NA19128 NA19130 NA19131 NA19137 NA19138 NA19140 NA19143 NA19144 1e+06 1e+06 1e+06 1e+06 1e+06 1e+06 1e+06 1e+06 NA19147 NA19152 NA19153 NA19159 NA19160 NA19171 NA19172 NA19190 1e+06 1e+06 1e+06 1e+06 1e+06 1e+06 1e+06 1e+06 NA19192 NA19193 NA19200 NA19201 NA19203 NA19204 NA19209 NA19210 1e+06 1e+06 1e+06 1e+06 1e+06 1e+06 1e+06 1e+06 NA19222 NA19225 NA19238 NA19239 NA19257 1e+06 1e+06 1e+06 1e+06 1e+06 None of these metrics (CPM, RPKM/FPKM, TPM) account for the other important confounding factor when comparing expression levels of genes across samples: the library composition, which may also be referred to as the relative size of the compared transcriptomes. This factor is not dependent on the sequencing technology, it is rather biological. For instance, when comparing transcriptomes of different tissues, there can be sets of genes in one tissue that consume a big chunk of the reads, while in the other tissues they are not expressed at all. This kind of imbalance in the composition of compared transcriptomes can lead to wrong conclusions about which genes are actually differentially expressed. This consideration is addressed in two popular R packages: DESeq2 (Love, Huber, and Anders 2014) and edgeR (Robinson, McCarthy, and Smyth 2010) each with a different algorithm. edgeR uses a normalization procedure called Trimmed Mean of M-values (TMM). DESeq2 implements a normalization procedure using median of Ratios, which is obtained by finding the ratio of the log-transformed count of a gene divided by the average of log-transformed values of the gene in all samples (geometric mean), and then taking the median of these values for all genes. The raw read count of the gene is finally divided by this value (median of ratios) to obtain the normalized counts. The DESeq2 normalization is automatically performed when using DESeq2 package (we will see it later). We now apply a TMM (trimmed mean of M-values) normalization which, as previously mentioned, was developed to correct the gene counts by the expression properties of the whole sample. The TMM normalization method is implemented in the Bioconductor’s tweeDEseq package and can be performed by: library(tweeDEseq) NormByTMM &lt;- normalizeCounts(counts.ok, method=&quot;TMM&quot;) Another type of normalization is CQN, available in the package cqn. It requires different steps that have been encapsulated in the function called normalizeCounts () from tweeDEseq. The function requires the length and the percentage of GC-content of each gene. library(cqn) annotation &lt;- geneAnnot[,c(&quot;Length&quot;, &quot;GCcontent&quot;)] NormByCQN &lt;- normalizeCounts(counts.ok, method=&quot;cqn&quot;, annot=annotation) RQ fit ..................................................................... SQN fitting ... | | | 0% | |=================== | 33% | |====================================== | 67% | |=========================================================| 100% . We now compare the performance of each normalization method. Assuming that between two samples, most genes are not differentially expressed, the distribution of the difference of log-ratios between the samples should be centered around 0 when data is correctly normalized. We thus examine the distributions for the 1st and 2nd sample under normalization by the total number of reads and by RPKM (Figure (fig:checkNorm): MbyT &lt;- log2(NormByCPM[, 1] / NormByCPM[, 2]) MbyRPKM &lt;- log2(NormByRPKM[, 1] / NormByRPKM[, 2]) par(mfrow=c(1,2)) hist(MbyT, xlab=&quot;log2-ratio&quot;, main=&quot;Total reads&quot;) abline(v=0, col=&quot;red&quot;) hist(MbyRPKM, xlab=&quot;log2-ratio&quot;, main=&quot;RPKM&quot;) abline(v=0, col=&quot;red&quot;) Figure 6.5: Comparison of log-ratio count intensity of samples 1 and 2 from the Pickrell dataset. Figure 6.5, however, does not show whether the null difference between samples holds for different levels of gene expression. With a MA-plot, one can check whether data has been correctly normalized at any expression level. The MA-plot is available from the Bioconductor package edgeR. The resulting plot can be seen in Figure 6.6 (top left part). In the X-axis the plot shows the mean between the log-ratios. In the Y-axis the plot shows the difference of log-ratios between the samples, similar to figure 6.5. The MA-plot is, therefore, the difference against the mean of the gene counts between the two samples. The red line shows the expected M-values as a function of A-values. In our example of non-normalized data, we can see that for genes with low counts the distribution of the difference between samples is not zero; in particular, we observe that sample 2 has more counts than sample 1. library(edgeR) par(mfrow=c(3,2)) maPlot(counts[,1], counts[,2], pch=19, cex=.5, ylim=c(-8,8), allCol=&quot;darkgray&quot;, lowess=TRUE, xlab=expression( A == log[2] (sqrt(Sample1 %.% Sample3)) ), ylab=expression(M == log[2](Sample1/Sample3))) grid(col=&quot;black&quot;) title(&quot;Raw data&quot;) maPlot(NormByCPM[,1], NormByCPM[,2], pch=19, cex=.5, ylim=c(-8,8), allCol=&quot;darkgray&quot;, lowess=TRUE, xlab=expression( A == log[2] (sqrt(Sample1 %.% Sample3)) ), ylab=expression(M == log[2](Sample1/Sample3))) grid(col=&quot;black&quot;) title(&quot;CPM normalization&quot;) NormByRPKM &lt;- NormByRPKM[complete.cases(NormByRPKM),] maPlot(NormByRPKM[,1], NormByRPKM[,2], pch=19, cex=.5, ylim=c(-8,8), allCol=&quot;darkgray&quot;, lowess=TRUE, xlab=expression( A == log[2] (sqrt(Sample1 %.% Sample3)) ), ylab=expression(M == log[2](Sample1/Sample3))) grid(col=&quot;black&quot;) title(&quot;RPKM normalization&quot;) NormByTPM &lt;- NormByTPM[complete.cases(NormByTPM),] maPlot(NormByTPM[,1], NormByTPM[,2], pch=19, cex=.5, ylim=c(-8,8), allCol=&quot;darkgray&quot;, lowess=TRUE, xlab=expression( A == log[2] (sqrt(Sample1 %.% Sample3)) ), ylab=expression(M == log[2](Sample1/Sample3))) grid(col=&quot;black&quot;) title(&quot;TPM normalization&quot;) maPlot(NormByTMM[,1], NormByTMM[,2], pch=19, cex=.5, ylim=c(-8,8), allCol=&quot;darkgray&quot;, lowess=TRUE, xlab=expression( A == log[2] (sqrt(Sample1 %.% Sample3)) ), ylab=expression(M == log[2](Sample1/Sample3))) grid(col=&quot;black&quot;) title(&quot;TMM normalization&quot;) maPlot(NormByCQN[,1], NormByCQN[,2], pch=19, cex=.5, ylim=c(-8,8), allCol=&quot;darkgray&quot;, lowess=TRUE, xlab=expression( A == log[2] (sqrt(Sample1 %.% Sample3)) ), ylab=expression(M == log[2](Sample1/Sample3))) grid(col=&quot;black&quot;) title(&quot;CQN normalization&quot;) Figure 6.6: MA-plot of Pickrell data on samples 1 and 3 for raw data and normalized data using CPM, RPKM, TPM, TMM and CQN methods. 6.3 Exploratory analysis of the read counts table A typical quality control, in this case interrogating the RNA-seq experiment design, is to measure the similarity of the samples with each other in terms of the quantified expression level profiles across a set of genes. One important observation to make is to see whether the most similar samples to any given sample are the biological replicates of that sample. This can be computed using unsupervised clustering techniques such as hierarchical clustering and visualized as a heatmap with dendrograms. Another most commonly applied technique is a dimensionality reduction technique called Principal Component Analysis (PCA) and visualized as a two-dimensional (or in some cases three-dimensional) scatter plot. 6.3.1 Clustering We can combine clustering and visualization of the clustering results by using heatmap functions that are available in a variety of R libraries. The basic R installation comes with the stats::heatmap () function. However, there are other libraries available in CRAN (e.g. pheatmap) or Bioconductor (e.g. ComplexHeatmap) that come with more flexibility and more appealing visualizations. Here we demonstrate a heatmap using the pheatmap package and the previously calculated NormByTPM matrix. As these matrices can be quite large, both computing the clustering and rendering the heatmaps can take a lot of resources and time. Therefore, a quick and informative way to compare samples is to select a subset of genes that are, for instance, most variable across samples, and use that subset to do the clustering and visualization. Let’s select the top 100 most variable genes among the samples. #compute the variance of each gene across samples V &lt;- apply(NormByTPM, 1, var) #sort the results by variance in decreasing order #and select the top 100 genes selectedGenes &lt;- names(V[order(V, decreasing = T)][1:100]) Now we can quickly produce a heatmap where samples and genes are clustered (see Figure @ref{fig:clust}). library(pheatmap) pheatmap(NormByTPM[selectedGenes,], scale = &#39;row&#39;, show_rownames = FALSE) 6.3.2 PCA Let’s make a PCA plot to see the clustering of replicates as a scatter plot in two dimensions. We can put a different color for our grouping variable (Figure @ref{fig:pcaRNAseq}). NOTE: Having clusters of individuals given a third variable (plate, population, …) can be a problem that must be corrected in downstream analyses. library(stats) library(ggplot2) library(ggfortify) #transpose the matrix M &lt;- t(NormByTPM[selectedGenes,]) # transform the counts to log2 scale M &lt;- log2(M + 1) #compute PCA pcaResults &lt;- prcomp(M) #plot PCA results making use of ggplot2&#39;s autoplot function #ggfortify is needed to let ggplot2 know about PCA data structure. autoplot(pcaResults, data = pData(pickrell.eset), colour = &#39;gender&#39;) Figure 6.7: PCA plot of samples using TPM counts 6.4 Differential expression analysis RNA-seq data are discrete therefore linear models, such that those implemented in limma cannot be applied. While it is common practice to apply logarithmic transformations before fitting linear models, the transformations depend on an offset level to account for zero counts, which, in turn, can affect the group differences assessed in regression models. Other transformations may be applied, however, it is more adequate to make inferences based on distributions of count data such as the Poisson or the negative binomial distributions . Negative binomial modeling is preferred over Poisson’s, as biological variability results in a difference between the mean and variance of the data. The negative binomial is defined by the parameters \\(\\lambda\\) and \\(\\phi\\) that model the intensity and overdispersion of data. Let us then assume that \\(X_{gA}\\) corresponds to the number of reads that mapped into gene \\(g\\) (\\(g=1, \\ldots, G\\)) across subjects within condition \\(A\\) and that \\(X_{gA} \\sim NB(\\lambda_{gA}, \\phi_g)\\). If counts in condition \\(B\\) also distribute \\(X_{gB} \\sim NB(\\lambda_{gB}, \\phi_g)\\) then we aim to test whether \\(\\lambda_{gA}\\) and \\(\\lambda_{gB}\\) are significantly different across all \\(g\\). The dispersion of the gene \\(\\phi_g\\) cannot be estimated when few individuals are analyzed, therefore we can: There is another approach proposed by Law, et al. 2014 that makes a transformation of the count data (voom) that allows the use of normal linear models to analyze RNA-sea experiments. This method estimates the mean-variance relationship of the log-counts, generates some weights for each observation that are used in the linear models implemented in limma. knitr::include_graphics(&#39;figures/mean_variance.png&#39;) We demonstrate the use of both DESeq2 and voom using our previous example of lymphoblastoid cell lines. Our final aim is to detect the genes that are differentially expressed between males and females. 6.4.1 DESeq2 Let us start with DESeq2 workflow and how it calculates differential expression. The read counts are normalized by computing size factors, which addresses the differences not only in the library sizes, but also the library compositions. For each gene, a dispersion estimate is calculated. The dispersion value computed by DESeq2 is equal to the squared coefficient of variation (variation divided by the mean). A line is fit across the dispersion estimates of all genes computed in step 2 versus the mean normalized counts of the genes (Figure ??). Dispersion values of each gene are shrunk towards the fitted line in step 3. A Generalized Linear Model is fitted which considers additional confounding variables related to the experimental design such as sequencing batches, treatment, temperature, patient’s age, sequencing technology, etc., and uses negative binomial distribution for fitting count data. For a given contrast (e.g. treatment type: drug-A versus untreated), a test for differential expression is carried out against the null hypothesis that the log fold change of the normalized counts of the gene in the given pair of groups is exactly zero. It adjusts p-values for multiple-testing. In order to carry out a differential expression analysis using DESeq2, three kinds of inputs are necessary: The read count table: This table must be raw read counts as integers that are not processed in any form by a normalization technique. The rows represent features (e.g. genes, transcripts, genomic intervals) and columns represent samples. A colData table: This table describes the experimental design. A design formula: This formula is needed to describe the variable of interest in the analysis (e.g. treatment status) along with (optionally) other covariates (e.g. batch, temperature, sequencing technology). Let’s define these inputs: countData &lt;- as.matrix(counts) #define the experimental setup colData &lt;- pData(pickrell.eset) #define the design formula designFormula &lt;- as.formula(~ gender) Now, we are ready to run DESeq2. library(DESeq2) #create a DESeq dataset object from the count matrix and the colData dds &lt;- DESeqDataSetFromMatrix(countData = countData, colData = colData, design = designFormula) #print dds object to see the contents print(dds) class: DESeqDataSet dim: 52580 69 metadata(1): version assays(1): counts rownames(52580): ENSG00000000003 ENSG00000000005 ... LRG_98 LRG_99 rowData names(0): colnames(69): NA18486 NA18498 ... NA19239 NA19257 colData names(4): num.tech.reps population study gender The DESeqDataSet object contains all the information about the experimental setup, the read counts, and the design formulas. Certain functions can be used to access this information separately: rownames(dds) shows which features are used in the study (e.g. genes), colnames(dds) displays the studied samples, counts(dds) displays the count table, and colData(dds) displays the experimental setup. Remove genes that have almost no information in any of the given samples. dds &lt;- dds[ rowSums(counts(dds)) &gt; 1, ] Now, we can use the DESeq () function of DESeq2, which is a wrapper function that implements estimation of size factors to normalize the counts, estimation of dispersion values, and computing a GLM model based on the experimental design formula. This function returns a DESeqDataSet object, which is an updated version of the dds object that we pass to the function as input. dds &lt;- DESeq(dds) Now, we can compare and contrast the samples based on different variables of interest. In this case, we currently have only one variable, which is the gender variable that determines if a sample is a male or a female. DEresults &lt;- results(dds, contrast = c(&quot;gender&quot;, &#39;male&#39;, &#39;female&#39;)) DEresults &lt;- DEresults[order(DEresults$pvalue),] Thus we have obtained a table containing the differential expression status of male samples compared to the femal samples (NOTE: in general you will have contrast = c(\"group\", 'CASE', 'CONTROL')). It is important to note that the sequence of the elements provided in the contrast argument determines which group of samples are to be used as the control. This impacts the way the results are interpreted, for instance, if a gene is found up-regulated (has a positive log2 fold change), the up-regulation status is only relative to the factor that is provided as control. In this case, we used samples from the “female” group as control and contrasted the samples from the “male” group with respect to the “female” samples. Thus genes with a positive log2 fold change are called up-regulated in females with respect to females, while genes with a negative log2 fold change are down-regulated in the males. Whether the deregulation is significant or not, warrants assessment of the adjusted p-values. Let’s have a look at the contents of the DEresults table. DEresults log2 fold change (MLE): gender male vs female Wald test p-value: gender male vs female DataFrame with 11916 rows and 6 columns baseMean log2FoldChange lfcSE stat &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; ENSG00000129824 153.69742 10.38990 0.339760 30.5801 ENSG00000099749 15.35847 7.58113 0.346235 21.8959 ENSG00000198692 8.19446 6.79870 0.369269 18.4112 ENSG00000154620 10.90122 5.88750 0.344185 17.1056 ENSG00000157828 5.71040 6.11005 0.462473 13.2117 ... ... ... ... ... ENSG00000136352 0.1022197 9.16111e-05 2.0766732 4.41144e-05 ENSG00000081800 0.0923587 9.14659e-05 2.1146437 4.32536e-05 ENSG00000184302 0.0920789 9.14620e-05 2.1156773 4.32306e-05 ENSG00000203993 93.4492562 -2.71260e-06 0.0904723 -2.99827e-05 ENSG00000204019 0.0000000 0.00000e+00 0.0000000 0.00000e+00 pvalue padj &lt;numeric&gt; &lt;numeric&gt; ENSG00000129824 2.24914e-205 2.00444e-201 ENSG00000099749 2.84178e-106 1.26630e-102 ENSG00000198692 1.06759e-75 3.17147e-72 ENSG00000154620 1.34765e-65 3.00257e-62 ENSG00000157828 7.51022e-40 1.33862e-36 ... ... ... ENSG00000136352 0.999965 NA ENSG00000081800 0.999965 NA ENSG00000184302 0.999966 NA ENSG00000203993 0.999976 0.999976 ENSG00000204019 1.000000 NA The first three lines in this output show the contrast and the statistical test that were used to compute these results, along with the dimensions of the resulting table (number of columns and rows). Below these lines is the actual table with 6 columns: baseMean represents the average normalized expression of the gene across all considered samples. log2FoldChange represents the base-2 logarithm of the fold change of the normalized expression of the gene in the given contrast. lfcSE represents the standard error of log2 fold change estimate, and stat is the statistic calculated in the contrast which is translated into a pvalue and adjusted for multiple testing in the padj column. 6.4.1.1 Diagnostic plots At this point, before proceeding to do any downstream analysis and jumping to conclusions about the biological insights that are reachable with the experimental data at hand, it is important to do some more diagnostic tests to improve our confidence about the quality of the data and the experimental setup. 6.4.1.1.1 MA plot An MA plot is useful to observe if the data normalization worked well (Figure 6.8). The MA plot is a scatter plot where the x-axis denotes the average of normalized counts across samples and the y-axis denotes the log fold change in the given contrast. Most points are expected to be on the horizontal 0 line (most genes are not expected to be differentially expressed). DESeq2::plotMA(object = dds, ylim = c(-5, 5)) Figure 6.8: MA plot of differentital expression results 6.4.1.1.2 Volcano plot We highly recommend to read the vignette of EnhancedVolcano Bioconductor package to get this type of plots. This figure has the default cut-off for log2FC as &gt;|2| and the default cut-off for P value as 10e-6.: library(EnhancedVolcano) EnhancedVolcano(DEresults, lab = rownames(DEresults), x = &#39;log2FoldChange&#39;, y = &#39;pvalue&#39;) Figure 6.9: Volcano plot males vs females Pickrell data 6.4.1.1.3 P-value distribution It is also important to observe the distribution of raw p-values (Figure 6.10). We expect to see a peak around low p-values and a uniform distribution at P-values above 0.1. Otherwise, adjustment for multiple testing does not work and the results are not meaningful. library(ggplot2) ggplot(data = as.data.frame(DEresults), aes(x = pvalue)) + geom_histogram(bins = 100) Figure 6.10: P-value distribution genes before adjusting for multiple testing. This type of plots indicates that there is unwanted variability driven by unobserved variables. Let’s talk about it later. 6.4.1.1.4 PCA plot A final diagnosis is to check the biological reproducibility of the sample replicates in a PCA plot or a heatmap. To plot the PCA results, we need to extract the normalized counts from the DESeqDataSet object. It is possible to color the points in the scatter plot by the variable of interest, which helps to see if the replicates cluster well (Figure 6.11). # extract normalized counts from the DESeqDataSet object countsNormalized &lt;- DESeq2::counts(dds, normalized = TRUE) # select top 500 most variable genes selectedGenes &lt;- names(sort(apply(countsNormalized, 1, var), decreasing = TRUE)[1:500]) pcaResults2 &lt;- prcomp(t(countsNormalized[selectedGenes,])) autoplot(pcaResults2, data = pData(pickrell.eset), colour = &#39;gender&#39;) Figure 6.11: Principal component analysis plot based on top 500 most variable genes. Alternatively, the normalized counts can be transformed using the DESeq2::rlog () or DESeq2::vst () function (which is much faster) and DESeq2::plotPCA () can be readily used to plot the PCA results rld &lt;- vst(dds) DESeq2::plotPCA(rld, ntop = 500, intgroup = &#39;gender&#39;) + ylim(-25, 25) + theme_bw() Figure 6.12: PCA plot of top 500 most variable genes. A similar plot to the MA plot is the RLE (Relative Log Expression) plot that is useful in finding out if the data at hand needs normalization (Gandolfo and Speed 2018). Sometimes, even the datasets normalized using the explained methods above may need further normalization due to unforeseen sources of variation that might stem from the library preparation, the person who carries out the experiment, the date of sequencing, the temperature changes in the laboratory at the time of library preparation, and so on and so forth. The RLE plot is a quick diagnostic that can be applied on the raw or normalized count matrices to see if further processing is required. Let’s do RLE plots on the raw counts and normalized counts using the EDASeq package. library(EDASeq) par(mfrow = c(2, 1)) plotRLE(DESeq2::counts(dds, normalized = FALSE), outline=FALSE, ylim=c(-2, 2), col = as.numeric(colData$gender), main = &#39;Raw counts&#39;) plotRLE(DESeq2::counts(dds, normalized = TRUE), outline=FALSE, ylim=c(-2, 2), col = as.numeric(colData$gender), main = &#39;Normalized Counts (DESeq2)&#39;) Here the RLE plot is comprised of boxplots, where each box-plot represents the distribution of the relative log expression of the genes expressed in the corresponding sample. Each gene’s expression is divided by the median expression value of that gene across all samples. Then this is transformed to log scale, which gives the relative log expression value for a single gene. The RLE values for all the genes from a sample are visualized as a boxplot. Ideally the boxplots are centered around the horizontal zero line and are as tightly distributed as possible (Risso, et al. 2014). From the plots that we have made for the raw and normalized count data, we can observe how the normalized dataset has improved upon the raw count data for all the samples. However, in some cases, it is important to visualize RLE plots in combination with other diagnostic plots such as PCA plots, heatmaps, and correlation plots to see if there is more unwanted variation in the data, which can be further accounted for using packages such as RUVSeq (Risso, et al. 2014) and sva (Leek, et al. 2012). We will cover details about the RUVSeq and sva packages to account for unwanted sources of noise in RNA-seq datasets in later sections. 6.4.2 voom The analyses using voom are similar to those performed using limma the only difference is that count data is heteroscedastic. Basically, in order to remove Heteroscedasticity edgeR proposed to do a transformation of count data called voom. Here, we have the core we need to use for thi approach library(limma) design &lt;- model.matrix( ~ gender, data=colData) v &lt;- voom(counts, design=design, plot=TRUE) Figure 6.13: Mean-variance relationsip corresponding to the Pickrell dataset. Figure 6.13 shows the mean-variance relationship, from which precision weights are given to the count data, so continuous data are derived and analyzed by the usual limma procedure fit &lt;- lmFit(v, design) fit &lt;- eBayes(fit) topTable(fit, coef=ncol(design)) logFC AveExpr t P.Value ENSG00000129824 9.1311273 1.95469533 54.225084 1.065179e-64 ENSG00000099749 6.1321934 0.40983758 45.639189 6.485999e-59 ENSG00000198692 5.1906429 -0.03456802 35.287216 2.001501e-50 ENSG00000154620 4.9963042 0.48128403 25.017166 1.672057e-39 ENSG00000157828 4.1312237 -0.38999476 16.850518 5.322729e-28 ENSG00000006757 -0.9164784 5.30180979 -9.994009 1.027507e-15 ENSG00000183878 1.8245692 -1.50072787 10.254164 3.210781e-16 ENSG00000092377 0.7785641 -1.95781202 4.607544 1.524213e-05 ENSG00000177606 -0.5767409 8.24149085 -4.269167 5.368351e-05 ENSG00000143921 0.8071775 -1.86105437 4.513827 2.170952e-05 adj.P.Val B ENSG00000129824 5.600714e-60 67.155001 ENSG00000099749 1.705169e-54 56.640302 ENSG00000198692 3.507964e-46 48.692481 ENSG00000154620 2.197919e-35 41.492680 ENSG00000157828 5.597382e-24 30.056641 ENSG00000006757 7.718044e-12 20.728249 ENSG00000183878 2.813714e-12 15.860830 ENSG00000092377 8.974261e-02 1.957700 ENSG00000177606 8.974261e-02 1.735214 ENSG00000143921 8.974261e-02 1.623161 We see that the top genes with significant differences of transcription between males and females are consistent with those found using the DESeq2. Other plots implemented in limma can be used to visually inspect the results. volcanoplot(fit, coef=2, highlight = 5, names = rownames(fit$coefficients)) Figure 6.14: Volcano plot 6.5 Accounting for additional sources of variation When doing a differential expression analysis in a case-control setting, the variable of interest, i.e. the variable that explains the separation of the case samples from the control, is usually the treatment, genotypic differences, a certain phenotype, etc. However, in reality, depending on how the experiment and the sequencing were designed, there may be additional factors that might contribute to the variation between the compared samples. Sometimes, such variables are known, for instance, the date of the sequencing for each sample (batch information), or the temperature under which samples were kept. Such variables are not necessarily biological but rather technical, however, they still impact the measurements obtained from an RNA-seq experiment. Such variables can introduce systematic shifts in the obtained measurements. Here, we will demonstrate: firstly how to account for such variables using DESeq2, when the possible sources of variation are actually known; secondly, how to account for such variables when all we have is just a count table but we observe that the variable of interest only explains a small proportion of the differences between case and control samples. 6.5.1 Accounting for covariates using DESeq2 For demonstration purposes, we will use a subset of the count table obtained for a heart disease study, where there are RNA-seq samples from subjects with normal and failing hearts. We will use a subset of the samples, focusing on 6 case and 6 control samples and we only consider protein-coding genes (for speed concerns). Data are available at a package called compGenomRdata that can be installed with: devtools::install_github(&quot;compgenomr/compGenomRData&quot;) This package contains text, RDS and other genomic specific data. Let’s import count and colData for the experiment having data on the heart disease study. counts_file &lt;- system.file(&#39;extdata/rna-seq/SRP021193.raw_counts.tsv&#39;, package = &#39;compGenomRData&#39;) colData_file &lt;- system.file(&#39;extdata/rna-seq/SRP021193.colData.tsv&#39;, package = &#39;compGenomRData&#39;) counts &lt;- read.table(counts_file) colData &lt;- read.table(colData_file, header = T, sep = &#39;\\t&#39;, stringsAsFactors = TRUE) Let’s take a look at how the samples cluster by calculating the TPM counts as displayed as a heatmap in Figure 6.15. library(pheatmap) #find gene length normalized values geneLengths &lt;- counts$width rpk &lt;- apply( subset(counts, select = c(-width)), 2, function(x) x/(geneLengths/1000)) #normalize by the sample size using rpk values tpm &lt;- apply(rpk, 2, function(x) x / sum(as.numeric(x)) * 10^6) selectedGenes &lt;- names(sort(apply(tpm, 1, var), decreasing = TRUE)[1:100]) pheatmap(tpm[selectedGenes,], scale = &#39;row&#39;, annotation_col = colData, show_rownames = FALSE) Figure 6.15: Visualizing batch effects in an experiment. Here we can see from the clusters that the dominating variable is the ‘Library Selection’ variable rather than the ‘diagnosis’ variable, which determines the state of the organ from which the sample was taken. Case and control samples are all mixed in both two major clusters. However, ideally, we’d like to see a separation of the case and control samples regardless of the additional covariates. When testing for differential gene expression between conditions, such confounding variables can be accounted for using DESeq2. Below is a demonstration of how we instruct DESeq2 to account for the ‘library selection’ variable: library(DESeq2) # remove the &#39;width&#39; column from the counts matrix countData &lt;- as.matrix(subset(counts, select = c(-width))) # set up a DESeqDataSet object dds &lt;- DESeqDataSetFromMatrix(countData = countData, colData = colData, design = ~ LibrarySelection + group) Now, we can run the differential expression analysis as has been demonstrated previously. # run DESeq dds &lt;- DESeq(dds) # extract results that are adjusted for &#39;LibrarySelection&#39; DEresults &lt;- results(dds, contrast = c(&#39;group&#39;, &#39;CASE&#39;, &#39;CTRL&#39;)) 6.5.2 Accounting for estimated covariates using RUVSeq In cases when the sources of potential variation are not known, it is worthwhile to use tools such as RUVSeq or sva that can estimate potential sources of variation and clean up the counts table from those sources of variation. Later on, the estimated covariates can be integrated into DESeq2’s design formula. Let’s see how to utilize the RUVseq package to first diagnose the problem and then solve it (NOTE: you will practice with sva in the exercises). Here, for demonstration purposes, we’ll use a count table from a lung carcinoma study in which a transcription factor (Ets homologous factor - EHF) is overexpressed and compared to the control samples with baseline EHF expression. Again, we only consider protein coding genes and use only five case and five control samples. The original data can be found on the recount2 database with the accession ‘SRP049988’. counts_file &lt;- system.file(&#39;extdata/rna-seq/SRP049988.raw_counts.tsv&#39;, package = &#39;compGenomRData&#39;) colData_file &lt;- system.file(&#39;extdata/rna-seq/SRP049988.colData.tsv&#39;, package = &#39;compGenomRData&#39;) counts &lt;- read.table(counts_file) colData &lt;- read.table(colData_file, header = T, sep = &#39;\\t&#39;, stringsAsFactors = TRUE) # simplify condition descriptions colData$source_name &lt;- ifelse(colData$group == &#39;CASE&#39;, &#39;EHF_overexpression&#39;, &#39;Empty_Vector&#39;) Let’s start by making heatmaps of the samples using TPM counts (see Figure 6.16). #find gene length normalized values geneLengths &lt;- counts$width rpk &lt;- apply( subset(counts, select = c(-width)), 2, function(x) x/(geneLengths/1000)) #normalize by the sample size using rpk values tpm &lt;- apply(rpk, 2, function(x) x / sum(as.numeric(x)) * 10^6) selectedGenes &lt;- names(sort(apply(tpm, 1, var), decreasing = T)[1:100]) pheatmap(tpm[selectedGenes,], scale = &#39;row&#39;, annotation_col = colData, cutree_cols = 2, show_rownames = FALSE) Figure 6.16: Diagnostic plot of lung carcinoma study. We can see that the overall clusters look fine, except that one of the case samples (CASE_5) clusters more closely with the control samples than the other case samples. This mis-clustering could be a result of some batch effect, or any other technical preparation steps. However, the colData object doesn’t contain any variables that we can use to pinpoint the exact cause of this. So, let’s use RUVSeq to estimate potential covariates to see if the clustering results can be improved. First, we set up the experiment: library(EDASeq) # remove &#39;width&#39; column from counts countData &lt;- as.matrix(subset(counts, select = c(-width))) # create a seqExpressionSet object using EDASeq package set &lt;- newSeqExpressionSet(counts = countData, phenoData = colData) Next, let’s make a diagnostic RLE plot on the raw count table. par(mfrow = c(1,2)) plotRLE(set, outline=FALSE, ylim=c(-4, 4), col=as.numeric(colData$group)) plotPCA(set, col = as.numeric(colData$group), adj = 0.5, ylim = c(-0.7, 0.5), xlim = c(-0.5, 0.5)) Figure 6.17: Diagnostic RLE and PCA plots based on raw count table The plot shows that normalization is required. Let us see what happen with TPM normalized counts. par(mfrow = c(1,2)) plotRLE(tpm, outline=FALSE, ylim=c(-4, 4), col=as.numeric(colData$group)) plotPCA(tpm, col=as.numeric(colData$group), adj = 0.5, ylim = c(-0.3, 1), xlim = c(-0.5, 0.5)) Figure 6.18: Diagnostic RLE and PCA plots based on TPM normalized count table. Both RLE and PCA plots look better on normalized data compared to raw data, but still suggest the necessity of further improvement, because the CASE_5 sample still clusters with the control samples. We haven’t yet accounted for the source of unwanted variation. 6.5.3 Removing unwanted variation from the data RUVSeq has three main functions for removing unwanted variation: RUVg(), RUVs(), and RUVr(). Here, we will demonstrate how to use RUVg and RUVs. RUVr will be left as an exercise. 6.5.3.1 Using RUVg One way of removing unwanted variation depends on using a set of reference genes that are not expected to change by the sources of technical variation. One strategy along this line is to use spike-in genes, which are artificially introduced into the sequencing run (Jiang, et al. 2011). However, there are many sequencing datasets that don’t have this spike-in data available. In such cases, an empirical set of genes can be collected from the expression data by doing a differential expression analysis and discovering genes that are unchanged in the given conditions. These unchanged genes are used to clean up the data from systematic shifts in expression due to the unwanted sources of variation. Another strategy could be to use a set of house-keeping genes as negative controls, and use them as a reference to correct the systematic biases in the data. Let’s use a list of ~500 house-keeping genes compiled here: https://www.tau.ac.il/~elieis/HKG/HK_genes.txt. library(RUVSeq) #source for house-keeping genes collection: #https://m.tau.ac.il/~elieis/HKG/HK_genes.txt HK_genes &lt;- read.table(url(&quot;https://m.tau.ac.il/~elieis/HKG/HK_genes.txt&quot;)) # let&#39;s take an intersection of the house-keeping genes with the genes available # in the count table house_keeping_genes &lt;- intersect(rownames(set), HK_genes$V1) We will now run RUVg() with the different number of factors of unwanted variation. We will plot the PCA after removing the unwanted variation. We should be able to see which \\(k\\) values (e.g. number of factors) produce better separation between sample groups. # now, we use these genes as the empirical set of genes as input to RUVg. # we try different values of k and see how the PCA plots look par(mfrow = c(2, 2)) for(k in 1:4) { set_g &lt;- RUVg(x = set, cIdx = house_keeping_genes, k = k) plotPCA(set_g, col=as.numeric(colData$group), cex = 0.9, adj = 0.5, main = paste0(&#39;with RUVg, k = &#39;,k), ylim = c(-1, 1), xlim = c(-1, 1), ) } Figure 6.19: PCA plots on RUVg normalized data with varying number of covariates (k). Based on the separation of case and control samples in the PCA plots in Figure 8.16, we choose \\(k = 1\\) and re-run the RUVg() function with the house-keeping genes to do more diagnostic plots. set_g &lt;- RUVg(x = set, cIdx = house_keeping_genes, k = 1) Now let’s do diagnostics: compare the count matrices with or without RUVg processing, comparing RLE plots (Figure @ref{fig:rleRUV}) and PCA plots (Figure @ref{fig:pcaRUV}) to see the effect of RUVg on the normalization and separation of case and control samples. par(mfrow = c(1,2)) plotRLE(set, outline=FALSE, ylim=c(-4, 4), col=as.numeric(colData$group), main = &#39;without RUVg&#39;) plotRLE(set_g, outline=FALSE, ylim=c(-4, 4), col=as.numeric(colData$group), main = &#39;with RUVg&#39;) Figure 6.20: RLE plots to observe the effect of RUVg. par(mfrow = c(1,2)) plotPCA(set, col=as.numeric(colData$group), adj = 0.5, main = &#39;without RUVg&#39;, ylim = c(-1, 0.5), xlim = c(-0.5, 0.5)) plotPCA(set_g, col=as.numeric(colData$group), adj = 0.5, main = &#39;with RUVg&#39;, ylim = c(-1, 0.5), xlim = c(-0.5, 0.5)) Figure 6.21: PCA plots to observe the effect of RUVg. We can observe that using RUVg() with house-keeping genes as reference has improved the clusters, however not yielded ideal separation. Probably the effect that is causing the ‘CASE_5’ to cluster with the control samples still hasn’t been completely eliminated. 6.5.3.2 Using RUVs There is another strategy of RUVSeq that works better in the presence of replicates in the absence of a confounded experimental design, which is the RUVs() function. Let’s see how that performs with this data. This time we don’t use the house-keeping genes. We rather use all genes as input to RUVs (). This function estimates the correction factor by assuming that replicates should have constant biological variation, rather, the variation in the replicates are the unwanted variation. # make a table of sample groups from colData differences &lt;- makeGroups(colData$group) ## looking for two different sources of unwanted variation (k = 2) ## use information from all genes in the expression object par(mfrow = c(2, 2)) for(k in 1:4) { set_s &lt;- RUVs(set, unique(rownames(set)), k=k, differences) #all genes plotPCA(set_s, col=as.numeric(colData$group), cex = 0.9, adj = 0.5, main = paste0(&#39;with RUVs, k = &#39;,k), ylim = c(-1, 1), xlim = c(-0.6, 0.6)) } Figure 6.22: PCA plots on RUVs normalized data with varying number of covariates (k). Based on the separation of case and control samples in the PCA plots in Figure 6.22, we can see that the samples are better separated even at k = 2 when using RUVs(). Here, we re-run the RUVs() function using k = 2, in order to do more diagnostic plots. We try to pick a value of k that is good enough to distinguish the samples by condition of interest. While setting the value of k to higher values could improve the percentage of explained variation by the first principle component to up to 61%, we try to avoid setting the value unnecessarily high to avoid removing factors that might also correlate with important biological differences between conditions. # we set k=2 set_s &lt;- RUVs(set, unique(rownames(set)), k=2, differences) Now let’s do diagnostics again: compare the count matrices with or without RUVs processing, comparing RLE plots (Figure 6.23) and PCA plots (Figure 6.24) to see the effect of RUVg on the normalization and separation of case and control samples. par(mfrow = c(1,2)) plotRLE(set, outline=FALSE, ylim=c(-4, 4), col=as.numeric(colData$group), main = &#39;without RUVs&#39;) plotRLE(set_s, outline=FALSE, ylim=c(-4, 4), col=as.numeric(colData$group), main = &#39;with RUVs&#39;) Figure 6.23: RLE plots to observe the effect of RUVs. par(mfrow = c(1,2)) plotPCA(set, col=as.numeric(colData$group), main = &#39;without RUVs&#39;, adj = 0.5, ylim = c(-0.75, 0.75), xlim = c(-0.75, 0.75)) plotPCA(set_s, col=as.numeric(colData$group), main = &#39;with RUVs&#39;, adj = 0.5, ylim = c(-0.75, 0.75), xlim = c(-0.75, 0.75)) Figure 6.24: PCA plots to observe the effect of RUVs. Let’s compare PCA results from RUVs and RUVg with the initial raw counts matrix. We will simply run the plotPCA() function on different normalization schemes. The resulting plots are in Figure ??: par(mfrow = c(1,3)) plotPCA(countData, col=as.numeric(colData$group), main = &#39;without RUV - raw counts&#39;, adj = 0.5, ylim = c(-0.75, 0.75), xlim = c(-0.75, 0.75)) plotPCA(set_g, col=as.numeric(colData$group), main = &#39;with RUVg&#39;, adj = 0.5, ylim = c(-0.75, 0.75), xlim = c(-0.75, 0.75)) plotPCA(set_s, col=as.numeric(colData$group), main = &#39;with RUVs&#39;, adj = 0.5, ylim = c(-0.75, 0.75), xlim = c(-0.75, 0.75)) It looks like RUVs () has performed better than RUVg() in this case. So, let’s use count data that is processed by RUVs() to re-do the initial heatmap. library(EDASeq) library(pheatmap) # extract normalized counts that are cleared from unwanted variation using RUVs normCountData &lt;- normCounts(set_s) selectedGenes &lt;- names(sort(apply(normCountData, 1, var), decreasing = TRUE))[1:500] pheatmap(normCountData[selectedGenes,], annotation_col = colData, show_rownames = FALSE, cutree_cols = 2, scale = &#39;row&#39;) Figure 6.25: Clustering samples using the top 500 most variable genes normalized using RUVs (k = 2). 6.5.3.3 Re-run DESeq2 with the computed variables Having computed the sources of variation using RUVs(), we can actually integrate these variables with DESeq2 to re-do the differential expression analysis. Here the idea is that the comparisons among groups will be ajusted for unwanted variability. library(DESeq2) #set up DESeqDataSet object dds &lt;- DESeqDataSetFromMatrix(countData = countData, colData = colData, design = ~ group) # filter for low count genes dds &lt;- dds[rowSums(DESeq2::counts(dds)) &gt; 10] # insert the covariates W1 and W2 (the code shows how to add 1-9) # computed using RUVs into DESeqDataSet object colData(dds) &lt;- cbind(colData(dds), pData(set_s)[rownames(colData(dds)), grep(&#39;W_[0-9]&#39;, colnames(pData(set_s)))]) # update the design formula for the DESeq analysis (save the variable of # interest to the last!) design(dds) &lt;- ~ W_1 + W_2 + group # repeat the analysis dds &lt;- DESeq(dds) # extract deseq results res &lt;- results(dds, contrast = c(&#39;group&#39;, &#39;CASE&#39;, &#39;CTRL&#39;)) res &lt;- res[order(res$padj),] head(res) log2 fold change (MLE): group CASE vs CTRL Wald test p-value: group CASE vs CTRL DataFrame with 6 rows and 6 columns baseMean log2FoldChange lfcSE stat pvalue padj &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; USP9Y 29712.5 5.16933 0.1189552 43.4561 0 0 RPS4Y1 140830.2 5.25714 0.0724517 72.5606 0 0 NTS 251982.3 -5.05912 0.0947389 -53.4007 0 0 RSPO3 94636.1 -1.76698 0.0470231 -37.5769 0 0 KRT19 367911.7 2.08835 0.0439788 47.4855 0 0 CES1 127785.8 4.65580 0.0858893 54.2070 0 0 "],
["references.html", "7 References", " 7 References Anderson, Carl A, Fredrik H Pettersson, Geraldine M Clarke, Lon R Cardon, Andrew P Morris, and Krina T Zondervan. 2010. “Data Quality Control in Genetic Case-Control Association Studies.” Nature Protocols 5 (9): 1564. Clayton, David G, Neil M Walker, Deborah J Smyth, Rebecca Pask, Jason D Cooper, Lisa M Maier, Luc J Smink, et al. 2005. “Population Structure, Differential Bias and Genomic Control in a Large-Scale, Case-Control Association Study.” Nature Genetics 37 (11): 1243. Consortium, Wellcome Trust Case Control, and others. 2007. “Genome-Wide Association Study of 14,000 Cases of Seven Common Diseases and 3,000 Shared Controls.” Nature 447 (7145): 661. Dudbridge, Frank. 2013. “Power and Predictive Accuracy of Polygenic Risk Scores.” PLoS Genetics 9 (3): e1003348. González, Juan R, Josep L Carrasco, Frank Dudbridge, Lluı́s Armengol, Xavier Estivill, and Victor Moreno. 2008. “Maximizing Association Statistics over Genetic Models.” Genetic Epidemiology 32 (3): 246–54. Lawrence, Michael, Wolfgang Huber, Hervé Pages, Patrick Aboyoun, Marc Carlson, Robert Gentleman, Martin T Morgan, and Vincent J Carey. 2013. “Software for Computing and Annotating Genomic Ranges.” PLoS Computational Biology 9 (8): e1003118. MacArthur, Jacqueline, Emily Bowler, Maria Cerezo, Laurent Gil, Peggy Hall, Emma Hastings, Heather Junkins, et al. 2016. “The New NHGRI-EBI Catalog of Published Genome-Wide Association Studies (GWAS Catalog).” Nucleic Acids Research 45 (D1): D896–D901. Pe’er, Itsik, Roman Yelensky, David Altshuler, and Mark J Daly. 2008. “Estimation of the Multiple Testing Burden for Genomewide Association Studies of Nearly All Common Variants.” Genetic Epidemiology 32 (4): 381–85. Price, Alkes L, Nick J Patterson, Robert M Plenge, Michael E Weinblatt, Nancy A Shadick, and David Reich. 2006. “Principal Components Analysis Corrects for Stratification in Genome-Wide Association Studies.” Nature Genetics 38 (8): 904. Price, Alkes L, Noah A Zaitlen, David Reich, and Nick Patterson. 2010. “New Approaches to Population Stratification in Genome-Wide Association Studies.” Nature Reviews Genetics 11 (7): 459. Purcell, Shaun, Benjamin Neale, Kathe Todd-Brown, Lori Thomas, Manuel AR Ferreira, David Bender, Julian Maller, et al. 2007. “PLINK: A Tool Set for Whole-Genome Association and Population-Based Linkage Analyses.” The American Journal of Human Genetics 81 (3): 559–75. Silverberg, Mark S, Judy H Cho, John D Rioux, Dermot PB McGovern, Jing Wu, Vito Annese, Jean-Paul Achkar, et al. 2009. “Ulcerative Colitis–Risk Loci on Chromosomes 1p36 and 12q15 Found by Genome-Wide Association Study.” Nature Genetics 41 (2): 216. Wigginton, Janis E, David J Cutler, and Gonçalo R Abecasis. 2005. “A Note on Exact Tests of Hardy-Weinberg Equilibrium.” The American Journal of Human Genetics 76 (5): 887–93. "],
["exercises.html", "8 Exercises 8.1 Bioconductor 8.2 Genetic association studies 8.3 GWAS 8.4 Microarray data analysis 8.5 RNAseq data analysis", " 8 Exercises Here we propose several exercises whose answers will have to be deliver through the Moodle. The data are in a folder called data_for_exercises. The answers will also be available in the Moodle site. 8.1 Bioconductor EXERCISE 1: Read PLINK data (‘obesity.bed’, ‘obesity.fam’, ‘obesity.bim’) that are available here 1. How many samples are genotyped? 2. How many SNPs are in the chromosome 10? 3. Get the SNP names available in the region chr2:134500-2300000. 4. In which chromosome is located the SNP rs1527354? 5. Get the number of individuals of each genoytpe corresponding to the SNP rs7859525. Which the homozygous normal genotype? EXERCISE 2: Install the Bioconductor package called airway and load the data airway which is a SummarizedExperiment by executing: library(airway) data(airway) 1. Print the object {\\tt airway} and interpret the output. 2. Get the table of counts (use {\\tt asssays} data) and the variables of the experiment (use {\\tt colData} function). 3. Verify that {\\tt SummarizedExperiment} objects check the dimension of the tables (think about the dimensions that should match). 4. Compare the number of counts of the gene ENSG00000000419 between treated and untreated cells (variable &#39;dex&#39;) using {\\tt t.test} function. EXERCISE 3: Recount2 provides data for different RNA-seq experiments. These includes data from GTEx or TCGA projects. We have downloaded a subset of data corresponding to breast cancer and created a variable called er which encodes the estrogen receptor status (Negative and Positive). The SummarizedExperiment object is called breast and is available in the file ‘breast_tcga.Rdata’. Load the data into R and answer the next questions 1. How many samples are in the `SummarizedExperiment` object? 2. And how many genes? 3. Which is the number of samples with positive estrogen receptor status (variable `er`)? 4. Subset the individuals having Negative strogen receptor status and draw a boxplot of the first gene. 5. Create a `SummarizedExperiment` object of the genomic region chr6:151.2-151.8Mb. How many genes are in that region? How many of them are annotated? That is, how many of them have a gene symbol name? (HINT: use `rowRanges()` function and remember that `mcols()` function is used to get acccess to columns in a `GRanges` object) EXERCISE 4: The file snpsGWAS.Rdata contains information about 28 SNPs that were called as a significantly associated with a given disease after performing a GWAS study. 1. Load this data into R. 2. Create a data.frame with the name of the SNP, its chromosome, its position and the allele name. 3. Add another column to this data.frame with the minor allele frequency (MAF) estimated from 1000 genomes (HINT: use `listAttributes` to retrieve the name of the attribute we are interested in). 4. Annotate the variants and get the gene symbol 5. How many SNPs are located in promoter regions? 8.2 Genetic association studies EXERCISE 5: Researchers are interested in assessing possible association between candidate SNPs and the response to treatment in patients diagnosed with major depression (file ‘DM.txt’ - NOTE: check how alleles are separated). The file also includes clinical information about other covariates of interest such as: + HDRS: Hamilton Depression Rating Scale (continuous variable) + PSICOT: Was the patient psychotic? (No and Yes) + MELANCOL: Was the patient melancholic? (No and Yes) + EPD_PREV: Number of previous episodes of depression (continuous variable) + RESP: Response to treatment (outcome) Answer the following questions: 1. Is it necessary to check HWE hypothesis for this example? 2. Is there any SNP associated with the response to the treatment? If so, write a sentence interpreting the results of that association (only for one SNP) 3. Does the result change after adjusting for other clinical covariates? 4. Create a plot with the p-values only for dominant, recessive and additive models 5. Compute the p-values using MAX-statistic for all SNPs EXERCISE 6: Researchers are now interested in assessing the effect of haplotypes on the response to treatment. Answer the following questions: 1. Which is the combination of SNPs (e.g. number of consecutive haplotypes) that is more associated with the response to treatment? (NOTE1: Try only haplotypes of length 2 up to 4) 2. Which is the most frequent haplotype? 3. Compute the OR of association and its 95\\% confidence intervals between the estimate haplotypes and the response to treatment EXERCISE 7: Researchers are now interested in creating a genetic score to predict the response to the treatment 1. Perform all the required steps to get such score and evaluate its performance using a ROC curve 8.3 GWAS EXERCISE 8: Researchers are interested in detecting new SNPs associated with BMI (body mass index). To do so, they performed a GWAS using DNA information about 425 individuals. Genotype information is available in plink format (files ‘coronary.bed’, ‘coronary.bim’, ‘coronary.fam’) while phenotypic information can be found in the file ‘coronary.txt’. 1. Read genotypes using `snpStats` library 2. Verify that both data sets are in the same order (NOTE: &#39;id&#39; variable in the file &#39;coronary.txt&#39; must be used since it corresponds to the unique patient number) 3. Perform some QC filtering of individuals 4. Remove those SNPs that do not pass QC (HWE and low MAF) 5. Assess association between BMI&#39; and the SNPs (NOTE: remember that you are analyzing a **quantitative trait**) 6. Calculate &#39;lambda&#39; and create a Q-Q plot to assess population stratification 7. Assess association between BMI&#39; and the SNPs adjusting for population stratification (variables &#39;ev3&#39; and &#39;ev4&#39; in the file &#39;coronary.txt&#39;) (NOTE: remember that you are analyzing a **quantitative trait**). Are there differences with crude analysis? 8. Create a Manhattan plot 8.4 Microarray data analysis EXERCISE 9: To be supplied 8.5 RNAseq data analysis EXERICSE 10: Download the data SRP029880 from recount2: http://duffel.rail.bio/recount/v2/SRP029880/rse_gene.Rdata. This file contains a RangedSummarizedExperiment object. Do the following tasks: Get the counts and colData tables. Normalize the counts using CPM, RPKM, TPM and TMM methods. Create the RLE and PCA plots for each method as well as for the raw data (do not forget to log-transform the data). Using TPM normalized data: Plot a heatmap of the top 500 most variable genes. Compare with the heatmap obtained using the 100 most variable genes. Re-do the heatmaps setting the scale argument to none, and column. Compare the results with scale = 'row'. Create a new variable called group by renaming the variable title as: normal, primary and metastasis. Perform a differential expression analysis using the variable group and get the list of differentially expressed genes comparing metastasis vs normal and primary vs normal. Create two MA and volcano plots to describe the previous comparisons. Examine the distribution of counts for a single gene (most associated with metastasis). Hint: use DESeq2::plotCounts () Do the same plot for the top-10 genes (this tries to mimic your supplementary material in your paper!) Investigate whether the analysis should be adjusted for other covariates. Re-do the differential expression analysis using edgeR (voom) package. Find out how much DESeq2 and edgeR agree on the list of differentially expressed genes. "]
]
